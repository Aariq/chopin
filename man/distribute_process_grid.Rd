% Generated by roxygen2: do not edit by hand
% Please edit documentation in scomps_rmarkdown_litr.rmd.
\name{distribute_process_grid}
\alias{distribute_process_grid}
\title{Process a given function in the entire or partial computational grids}
\usage{
distribute_process_grid(
  grids,
  grid_target_id = NULL,
  debug = FALSE,
  fun_dist,
  ...
)
}
\arguments{
\item{grids}{sf/SpatVector object. Computational grids.
It takes a strict assumption that the grid input is
an output of \code{get_computational_regions}}

\item{grid_target_id}{character(1) or numeric(2).
Default is NULL. If NULL, all grid_ids are used.
\code{"id_from:id_to"} format or
\code{c(unique(grid_id)[id_from], unique(grid_id)[id_to])}}

\item{debug}{logical(1). Prints error messages
if there were any errors during the calculation.}

\item{fun_dist}{\code{sf}, \code{terra} or \code{chopin} functions.}

\item{...}{Arguments passed to the argument \code{fun_dist}.}
}
\value{
a data.frame object with computation results.
For entries of the results, consult the function used in
\code{fun_dist} argument.
}
\description{
\link[future:multicore]{future::multicore}, \link[future:multisession]{future::multisession}, \link[future:cluster]{future::cluster}
with \link[doParallel:registerDoParallel]{doParallel::registerDoParallel} will parallelize the work
in each grid. For details of the terminology in \code{future} package,
refer to \link[future]{plan}. This function assumes that
users have one raster file and a sizable and spatially distributed
target locations. Each thread will process
\verb{ceiling(\eqn{|N_g|/|N_t|})} grids
where \eqn{|N_g|} denotes the number of grids and \eqn{|N_t|} denotes
the number of threads.
}
\note{
In dynamic dots (\code{...}), the first and second
arguments should be the \code{fun_dist} arguments where
sf/SpatVector objects are accepted.
Virtually any sf/terra functions that accept two arguments
can be put in \code{fun_dist}, but please be advised that
some spatial operations do not necessarily give the
exact result from what would have been done single-thread.
For example, distance calculated through this function may return the
lower value than actual because the computational region was reduced.
This would be the case especially where the target features
are spatially sparsely distributed.
}
\examples{
\dontrun{
library(future)
plan(multicore, workers = 4)
# Does not run ...
# distribute_process_grid()
}
}
\author{
Insang Song \email{geoissong@gmail.com}
}