[{"path":"/LICENSE.html","id":null,"dir":"","previous_headings":"","what":"MIT License","title":"MIT License","text":"Copyright (c) 2024 . Song Permission hereby granted, free charge, person obtaining copy software associated documentation files (“Software”), deal Software without restriction, including without limitation rights use, copy, modify, merge, publish, distribute, sublicense, /sell copies Software, permit persons Software furnished , subject following conditions: copyright notice permission notice shall included copies substantial portions Software. SOFTWARE PROVIDED “”, WITHOUT WARRANTY KIND, EXPRESS IMPLIED, INCLUDING LIMITED WARRANTIES MERCHANTABILITY, FITNESS PARTICULAR PURPOSE NONINFRINGEMENT. EVENT SHALL AUTHORS COPYRIGHT HOLDERS LIABLE CLAIM, DAMAGES LIABILITY, WHETHER ACTION CONTRACT, TORT OTHERWISE, ARISING , CONNECTION SOFTWARE USE DEALINGS SOFTWARE.","code":""},{"path":"/articles/v00_good_practice_parallelization.html","id":"assumptions","dir":"Articles","previous_headings":"","what":"Assumptions","title":"Good practice of scomps with HPC","text":"Users accessible HPC work Data stored distributed file systems (usually incorporated HPC system)","code":""},{"path":[]},{"path":"/articles/v00_good_practice_parallelization.html","id":"practice-for-minimizing-errors","dir":"Articles","previous_headings":"Basic workflow","what":"Practice for minimizing errors","title":"Good practice of scomps with HPC","text":"Especially higher-level functions","code":""},{"path":"/articles/v00_good_practice_parallelization.html","id":"raster-vector-overlay","dir":"Articles","previous_headings":"Basic workflow","what":"Raster-Vector overlay","title":"Good practice of scomps with HPC","text":"Make sp_index_grid() get padded grid objects example: c(xmin=0, ymin=0, xmax=10, ymax=10) extent vector element Preprocessed vector objects respect extent vector first list Preferably lists named Write future.apply script running extent list object Run small amount data estimate total computational demand Submit job proper amount computational assets","code":""},{"path":"/articles/v01_generate_computational_grid.html","id":"prepare-input-data","dir":"Articles","previous_headings":"","what":"Prepare input data","title":"Generate computational grids","text":"","code":"library(chopin) library(sf) library(terra) library(stars) library(dplyr)"},{"path":"/articles/v01_generate_computational_grid.html","id":"computational-grids","dir":"Articles","previous_headings":"","what":"Computational grids","title":"Generate computational grids","text":"","code":"library(chopin) library(dplyr) library(sf) library(terra) options(sf_use_s2 = FALSE) ncpoly <- system.file(\"shape/nc.shp\", package = \"sf\") ncsf <- sf::read_sf(ncpoly) ncsf <- sf::st_transform(ncsf, \"EPSG:5070\") plot(sf::st_geometry(ncsf)) ncpoints <- sf::st_sample(ncsf, 10000) plot(sf::st_geometry(ncpoints)) # st_sample output is st_sfc. We should convert it to sf ncpoints <- st_as_sf(ncpoints) ncpoints$pid <- seq(1, nrow(ncpoints))"},{"path":"/articles/v01_generate_computational_grid.html","id":"visualize-computational-grids","dir":"Articles","previous_headings":"","what":"Visualize computational grids","title":"Generate computational grids","text":"","code":"ncpoints_tr <- terra::vect(ncpoints) compregions <-     chopin::get_computational_regions(         ncpoints_tr,         mode = \"grid\",         nx = 8L,         ny = 5L,         padding = 1e4L     )  names(compregions) ## [1] \"original\" \"padded\" par(mfcol = c(1, 2)) plot(compregions$original, main = \"Original grids\") plot(compregions$padded, main = \"Padded grids\")"},{"path":"/articles/v01_generate_computational_grid.html","id":"notes","dir":"Articles","previous_headings":"","what":"Notes","title":"Generate computational grids","text":"Computational grids exhaustive split entire study region. take square buffer grid clip target raster vector.","code":""},{"path":"/articles/v02_distribute_process_ext.html","id":"plan","dir":"Articles","previous_headings":"","what":"Plan","title":"Distribute computational workloads over multiple threads","text":"peak memory consumption process small dataset: can employ power parallel processing far computational assets allow. total memory size may highest hurdle . Users strongly recommended run small (e.g., target points computational grid) example estimate total memory demand. Roughly speaking, machine equipped memory exceeding (number threads drawn) * (peak memory usage per thread). spatial temporal resolutions raster datasets spatial extent study period number points processed factors affect intermediate products’ complexity: use set polygons summarize raster values, intermediate memory consumption depend number vertices polygon datasets. recommend users simplify complex polygon features processing simplification trivially impact expected results. factors interact; instance, even raster fine resolution large spatial extent, find performance gain multi-thread processing small number points process. motivating example extracting mean elevation 10 kilometers circular point buffers using digital elevation model (DEM) data Shuttle Radar Topography Mission satellite. prepared dataset elevatr package. may consult package tutorial retrieving data directly OpenTopography via elevatr. start polygon dataset North Carolina. dataset included sf package.","code":"knitr::opts_chunk$set(message = FALSE, warning = FALSE) library(scomps) library(dplyr) library(sf) library(terra) library(future) library(future.apply) library(doFuture) library(tigris) options(sf_use_s2 = FALSE) set.seed(2023, kind = \"L'Ecuyer-CMRG\")"},{"path":"/articles/v02_distribute_process_ext.html","id":"use-case-1-mean-elevation-at-circular-points-buffers","dir":"Articles","previous_headings":"","what":"Use case 1: mean elevation at circular points buffers","title":"Distribute computational workloads over multiple threads","text":"plot chunk unnamed-chunk-3 demonstrate, set 1,000 random points generated inside polygons: plot chunk point-generation SpatRaster objects terra package serialized compress reuse elsewhere. serialization de-serialization, terra::wrap terra::unwrap need used. plot chunk load-srtm Modern computers usually two threads, enables users perform many tasks time. Provided users machines sufficient memory, runs much faster network storage, one can reduce total processing time employing multiple threads processing data. computation task divisible: simplest statement computation split must related another. dataset processing needs split beforehand. function call entire data memory refer location read values demand? function work parallel processing?","code":"ncpoly <- system.file(\"shape/nc.shp\", package = \"sf\") ncsf <- sf::read_sf(ncpoly) ncsf <- sf::st_transform(ncsf, \"EPSG:5070\") plot(sf::st_geometry(ncsf)) ncpoints <- sf::st_sample(ncsf, 10000) plot(sf::st_geometry(ncpoints)) # st_sample output is st_sfc. We should convert it to sf ncpoints <- st_as_sf(ncpoints) ncpoints$pid <- seq(1, nrow(ncpoints)) srtm <- terra::unwrap(readRDS(\"../../tests/testdata/nc_srtm15_otm.rds\")) srtm ## class       : SpatRaster  ## dimensions  : 1534, 2281, 1  (nrow, ncol, nlyr) ## resolution  : 391.5026, 391.5026  (x, y) ## extent      : 1012872, 1905890, 1219961, 1820526  (xmin, xmax, ymin, ymax) ## coord. ref. : +proj=aea +lat_0=23 +lon_0=-96 +lat_1=29.5 +lat_2=45.5 +x_0=0 +y_0=0 +datum=NAD83 +units=m +no_defs  ## source(s)   : memory ## name        : file928c3830468b  ## min value   :        -3589.291  ## max value   :         1946.400 plot(srtm) terra::crs(srtm) <- \"EPSG:5070\""},{"path":"/articles/v02_distribute_process_ext.html","id":"single-thread-processing","dir":"Articles","previous_headings":"Use case 1: mean elevation at circular points buffers","what":"Single-thread processing","title":"Distribute computational workloads over multiple threads","text":"","code":"ncpoints_tr <- terra::vect(ncpoints) system.time(     ncpoints_srtm <-         scomps::extract_with(             vector = ncpoints_tr,             raster = srtm,             id = \"pid\",             mode = \"buffer\",             radius = 1e4L) # 10,000 meters (10 km) ) ##    user  system elapsed  ##   6.067   0.199   6.266"},{"path":"/articles/v02_distribute_process_ext.html","id":"multi-thread-processing","dir":"Articles","previous_headings":"Use case 1: mean elevation at circular points buffers","what":"Multi-thread processing","title":"Distribute computational workloads over multiple threads","text":"Given data distributed across North Carolina, consider splitting points subregions grids. Please note get_computational_regions accept padding argument, users can get padded grids avoid missing raster cells original unit grid boundaries. plot chunk generate-compregion figure , padded grids overlaps one another. get_computational_regions automatically expand little input argument padding. Now, distribute computational process grids. Let’s find results look like. plot chunk vis-results plot chunk vis-results","code":"compregions <-     scomps::get_computational_regions(         ncpoints_tr,         mode = \"grid\",         nx = 8L,         ny = 5L,         padding = 1e4L     )  names(compregions) ## [1] \"original\" \"padded\" oldpar <- par() par(mfcol = c(1, 2)) plot(compregions$original, main = \"Original grids\") plot(compregions$padded, main = \"Padded grids\") par(oldpar) plan(multicore, workers = 4L) doFuture::registerDoFuture()  system.time(     ncpoints_srtm_mthr <-         scomps::distribute_process_grid(             grids = compregions,             grid_target_id = NULL,             fun_dist = scomps::extract_with,             vector = ncpoints_tr,             raster = srtm,             id = \"pid\",             mode = \"buffer\",             radius = 1e4L         ) ) ## Your input function was  ##             successfully run at CGRIDID: 1 ## Your input function was  ##             successfully run at CGRIDID: 2 ## Your input function was  ##             successfully run at CGRIDID: 3 ## Your input function was  ##             successfully run at CGRIDID: 4 ## Your input function was  ##             successfully run at CGRIDID: 5 ## Your input function was  ##             successfully run at CGRIDID: 6 ## Your input function was  ##             successfully run at CGRIDID: 7 ## Your input function was  ##             successfully run at CGRIDID: 8 ## Your input function was  ##             successfully run at CGRIDID: 9 ## Your input function was  ##             successfully run at CGRIDID: 10 ## Your input function was  ##             successfully run at CGRIDID: 11 ## Your input function was  ##             successfully run at CGRIDID: 12 ## Your input function was  ##             successfully run at CGRIDID: 13 ## Your input function was  ##             successfully run at CGRIDID: 14 ## Your input function was  ##             successfully run at CGRIDID: 15 ## Your input function was  ##             successfully run at CGRIDID: 16 ## Your input function was  ##             successfully run at CGRIDID: 17 ## Your input function was  ##             successfully run at CGRIDID: 18 ## Your input function was  ##             successfully run at CGRIDID: 19 ## Your input function was  ##             successfully run at CGRIDID: 20 ## Your input function was  ##             successfully run at CGRIDID: 21 ## Your input function was  ##             successfully run at CGRIDID: 22 ## Your input function was  ##             successfully run at CGRIDID: 23 ## Your input function was  ##             successfully run at CGRIDID: 24 ## Your input function was  ##             successfully run at CGRIDID: 25 ## Your input function was  ##             successfully run at CGRIDID: 26 ## Your input function was  ##             successfully run at CGRIDID: 27 ## Your input function was  ##             successfully run at CGRIDID: 28 ## Your input function was  ##             successfully run at CGRIDID: 29 ## Your input function was  ##             successfully run at CGRIDID: 30 ## Your input function was  ##             successfully run at CGRIDID: 31 ## Your input function was  ##             successfully run at CGRIDID: 32 ## Your input function was  ##             successfully run at CGRIDID: 33 ##    user  system elapsed  ##   6.558   1.304   3.540 ncpoints_srtm_mthr <-     ncpoints_srtm_mthr[order(ncpoints_srtm_mthr$pid),] all.equal(ncpoints_srtm, ncpoints_srtm_mthr) ## [1] \"Attributes: < Component \\\"row.names\\\": Mean relative difference: 0.6567904 >\" ## [2] \"Component \\\"mean\\\": Mean relative difference: 8.712634e-05\" ncpoints_s <-     merge(ncpoints, ncpoints_srtm) ncpoints_m <-     merge(ncpoints, ncpoints_srtm_mthr)  plot(ncpoints_s[, \"mean\"], main = \"Single-thread\") plot(ncpoints_m[, \"mean\"], main = \"Multi-thread\")"},{"path":"/articles/v02_distribute_process_ext.html","id":"distribute-computation-through-geographic-hierarchy","dir":"Articles","previous_headings":"Use case 1: mean elevation at circular points buffers","what":"Distribute computation through geographic hierarchy","title":"Distribute computational workloads over multiple threads","text":"consider “hierarchy,” usually embedded many geospatial datasets. Suppose want summarize elevation across census geographies North Carolina. census geographies highly organized order; think state, counties, zip code areas, census tracts, block groups, blocks. exhaustive higher order geographies (e.g., census block groups exhaustively delineated census tract), whereas (zip code areas exhaustively covered county). example, consider census tracts counties distribute computation task mean elevation values census tracts counties.","code":"nc_county <- file.path(\"../testdata/nc_hierarchy.gpkg\") nc_county <- sf::st_read(nc_county, layer = \"county\") ## Reading layer `county' from data source  ##   `/Users/songi2/Documents/GitHub/Scalable_GIS/tools/testdata/nc_hierarchy.gpkg'  ##   using driver `GPKG' ## Simple feature collection with 100 features and 1 field ## Geometry type: POLYGON ## Dimension:     XY ## Bounding box:  xmin: 1054155 ymin: 1341756 xmax: 1838923 ymax: 1690176 ## Projected CRS: NAD83 / Conus Albers nc_tracts <- file.path(\"../testdata/nc_hierarchy.gpkg\") nc_tracts <- sf::st_read(nc_tracts, layer = \"tracts\") ## Reading layer `tracts' from data source  ##   `/Users/songi2/Documents/GitHub/Scalable_GIS/tools/testdata/nc_hierarchy.gpkg'  ##   using driver `GPKG' ## Simple feature collection with 2672 features and 1 field ## Geometry type: MULTIPOLYGON ## Dimension:     XY ## Bounding box:  xmin: 1054155 ymin: 1341756 xmax: 1838923 ymax: 1690176 ## Projected CRS: NAD83 / Conus Albers nc_county <- sf::st_transform(nc_county, \"EPSG:5070\") nc_tracts <- sf::st_transform(nc_tracts, \"EPSG:5070\") nc_tracts$COUNTY <-     substr(nc_tracts$GEOID, 1, 5)"},{"path":"/articles/v02_distribute_process_ext.html","id":"single-thread-processing-1","dir":"Articles","previous_headings":"Use case 1: mean elevation at circular points buffers","what":"Single-thread processing","title":"Distribute computational workloads over multiple threads","text":"","code":"system.time(     nc_elev_tr_single <- scomps::extract_with(         vector = nc_tracts,         raster = srtm,         id = \"GEOID\",         mode = \"polygon\"     ) ) ##    user  system elapsed  ##   0.992   0.033   1.026"},{"path":"/articles/v02_distribute_process_ext.html","id":"multi-thread-processing-through-hierarchy","dir":"Articles","previous_headings":"Use case 1: mean elevation at circular points buffers","what":"Multi-thread processing through hierarchy","title":"Distribute computational workloads over multiple threads","text":"clearly shown several thousands features may get benefits parallel processing. However, approach helpful geographic area large raster data large handle.","code":"system.time(     nc_elev_tr_distr <-         scomps::distribute_process_hierarchy(             regions = nc_county, # higher level geometry             split_level = \"GEOID\", # higher level unique id             fun_dist = scomps::extract_with,             vector = nc_tracts, # lower level geometry             raster = srtm,             id = \"GEOID\", # lower level unique id             func = \"mean\"         ) ) ##    user  system elapsed  ##   0.021   0.015   1.285"},{"path":"/articles/v02_distribute_process_ext.html","id":"multi-thread-processing-over-large-rasters","dir":"Articles","previous_headings":"Use case 1: mean elevation at circular points buffers","what":"Multi-thread processing over large rasters","title":"Distribute computational workloads over multiple threads","text":"many cases users parallelized multiple files, .e., large raster files. Leveraging memory-saving terra’s C++ pointers, users want use distribute_process_multirasters, assumed raster file paths distribute. standard vector-raster overlays, distribute_process_multirasters help especially users multiple sizable raster files extract values moderately sized vectors.","code":"ncpath <- \"../testdata/nc_hierarchy.gpkg\" nccnty <- terra::vect(ncpath, layer = \"county\") ncelev <- terra::unwrap(readRDS(\"../testdata/nc_srtm15_otm.rds\")) terra::crs(ncelev) <- \"EPSG:5070\" names(ncelev) <- c(\"srtm15\") tdir <- tempdir() terra::writeRaster(ncelev, file.path(tdir, \"test1.tif\"), overwrite = TRUE) terra::writeRaster(ncelev, file.path(tdir, \"test2.tif\"), overwrite = TRUE) terra::writeRaster(ncelev, file.path(tdir, \"test3.tif\"), overwrite = TRUE) terra::writeRaster(ncelev, file.path(tdir, \"test4.tif\"), overwrite = TRUE) terra::writeRaster(ncelev, file.path(tdir, \"test5.tif\"), overwrite = TRUE)  testfiles <- list.files(tempdir(), pattern = \"*.tif$\", full.names = TRUE) testfiles ## [1] \"/var/folders/58/7rn_bn5d6k3_cxwnzdhswpz4n0z2n9/T//Rtmp1SCbAI/test1.tif\" ## [2] \"/var/folders/58/7rn_bn5d6k3_cxwnzdhswpz4n0z2n9/T//Rtmp1SCbAI/test2.tif\" ## [3] \"/var/folders/58/7rn_bn5d6k3_cxwnzdhswpz4n0z2n9/T//Rtmp1SCbAI/test3.tif\" ## [4] \"/var/folders/58/7rn_bn5d6k3_cxwnzdhswpz4n0z2n9/T//Rtmp1SCbAI/test4.tif\" ## [5] \"/var/folders/58/7rn_bn5d6k3_cxwnzdhswpz4n0z2n9/T//Rtmp1SCbAI/test5.tif\" res <- distribute_process_multirasters(       filenames = testfiles,       fun_dist = extract_with_polygons,       polys = nccnty,       surf = ncelev,       id = \"GEOID\",       func = \"mean\"     )  knitr::kable(head(res))"},{"path":"/articles/v02_distribute_process_ext.html","id":"distributing-sfterra-functions","dir":"Articles","previous_headings":"Use case 1: mean elevation at circular points buffers","what":"Distributing sf/terra functions","title":"Distribute computational workloads over multiple threads","text":"Users also can pass generic terra functions multiple threads. considerations apply: - function calculate nearest distance, edge cases may present especially target dataset sparse located padded calculation extent. example, users want distribute terra::nearest() calculate nearest distance ranch locations primary roads, ranch locations might destination primary roads calculation grids finely defined. - strongly assume users unique identifiers input data. passed argument distribute_process_* functions expected include id argument designate origin locations’ unique identifiers.","code":""},{"path":"/articles/v02_distribute_process_ext.html","id":"example","dir":"Articles","previous_headings":"Use case 1: mean elevation at circular points buffers > Distributing sf/terra functions","what":"Example","title":"Distribute computational workloads over multiple threads","text":"example shows distribute terra function nearest distributed regular computational grids.","code":"pnts <- readRDS(\"../testdata/nc_random_point.rds\") pnts <- terra::vect(pnts) rd1 <- terra::vect(     file.path(\"../testdata/ncroads_first.gpkg\"))  pnts <- terra::project(pnts, \"EPSG:5070\") rd1 <- terra::project(rd1, \"EPSG:5070\")   nccompreg <-     get_computational_regions(                               input = pnts,                               mode = \"grid\",                               nx = 6L,                               ny = 4L,                               padding = 3e4L)    future::plan(future::multicore, workers = 6L)  system.time( res <-   distribute_process_grid(                           grids = nccompreg,                           fun_dist = terra::nearest,                           x = pnts,                           y = rd1) ) ## Your input function was  ##             successfully run at CGRIDID: 1 ## Your input function was  ##             successfully run at CGRIDID: 2 ## Your input function was  ##             successfully run at CGRIDID: 3 ## Your input function was  ##             successfully run at CGRIDID: 4 ## Your input function was  ##             successfully run at CGRIDID: 5 ## Your input function was  ##             successfully run at CGRIDID: 6 ## Your input function was  ##             successfully run at CGRIDID: 7 ## Your input function was  ##             successfully run at CGRIDID: 8 ## Your input function was  ##             successfully run at CGRIDID: 9 ## Your input function was  ##             successfully run at CGRIDID: 10 ## Your input function was  ##             successfully run at CGRIDID: 11 ## Your input function was  ##             successfully run at CGRIDID: 12 ## Your input function was  ##             successfully run at CGRIDID: 13 ## Your input function was  ##             successfully run at CGRIDID: 14 ## Your input function was  ##             successfully run at CGRIDID: 15 ## Your input function was  ##             successfully run at CGRIDID: 16 ## Your input function was  ##             successfully run at CGRIDID: 17 ## Your input function was  ##             successfully run at CGRIDID: 18 ## Your input function was  ##             successfully run at CGRIDID: 19 ## Your input function was  ##             successfully run at CGRIDID: 20 ##    user  system elapsed  ##   0.311   0.266   0.197 system.time(   restr <- terra::nearest(x = pnts, y = rd1) ) ##    user  system elapsed  ##   0.034   0.001   0.036"},{"path":"/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Insang Song. Author, maintainer. Kyle Messier. Author, contributor.","code":""},{"path":"/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Song , Messier K (2024). chopin: CHOPIN: Computation Climate Health research Parallelized INfrastructure. R package version 0.2.0.01242024.","code":"@Manual{,   title = {chopin: CHOPIN: Computation for Climate and Health research On Parallelized INfrastructure},   author = {Insang Song and Kyle Messier},   year = {2024},   note = {R package version 0.2.0.01242024}, }"},{"path":"/index.html","id":"scalable_gis","dir":"","previous_headings":"","what":"CHOPIN: Computation for Climate and Health research On Parallelized\n    INfrastructure","title":"CHOPIN: Computation for Climate and Health research On Parallelized\n    INfrastructure","text":"Scalable GIS methods environmental climate data analysis","code":""},{"path":"/index.html","id":"basic-design","dir":"","previous_headings":"","what":"Basic design","title":"CHOPIN: Computation for Climate and Health research On Parallelized\n    INfrastructure","text":"Processing functions accept sf/terra classes spatial data. Raster-vector overlay done exactextractr. extract_with_polygons extract_with_buffer calculate_sedc: calculate sums exponentially decaying contributions aw_covariates: area-weighted covariates based target reference polygons distribute_process_grid distribute_process_hierarchy","code":""},{"path":"/index.html","id":"use-case","dir":"","previous_headings":"","what":"Use case","title":"CHOPIN: Computation for Climate and Health research On Parallelized\n    INfrastructure","text":"Please refer small example extracting mean altitude values circular point buffers census tracts North Carolina.","code":"library(chopin) library(dplyr) library(sf) library(terra) library(future) library(future.apply) library(doFuture) library(tigris) options(sf_use_s2 = FALSE) set.seed(2023, kind = \"L'Ecuyer-CMRG\") ncpoly <- system.file(\"shape/nc.shp\", package = \"sf\") ncsf <- sf::read_sf(ncpoly) ncsf <- sf::st_transform(ncsf, \"EPSG:5070\") plot(sf::st_geometry(ncsf))"},{"path":"/index.html","id":"generate-random-points-in-nc","dir":"","previous_headings":"","what":"Generate random points in NC","title":"CHOPIN: Computation for Climate and Health research On Parallelized\n    INfrastructure","text":"Ten thousands random point locations generated inside counties North Carolina.","code":"ncpoints <- sf::st_sample(ncsf, 10000) plot(sf::st_geometry(ncpoints)) # st_sample output is st_sfc. We should convert it to sf ncpoints <- st_as_sf(ncpoints) ncpoints$pid <- seq(1, nrow(ncpoints))"},{"path":"/index.html","id":"target-dataset-shuttle-radar-topography-mission","dir":"","previous_headings":"","what":"Target dataset: Shuttle Radar Topography Mission","title":"CHOPIN: Computation for Climate and Health research On Parallelized\n    INfrastructure","text":"use elevation dataset moderate spatial resolution (approximately 400 meters 0.25 miles).","code":"srtm <- terra::unwrap(readRDS(\"../../tests/testdata/nc_srtm15_otm.rds\")) srtm #> class       : SpatRaster  #> dimensions  : 1534, 2281, 1  (nrow, ncol, nlyr) #> resolution  : 391.5026, 391.5026  (x, y) #> extent      : 1012872, 1905890, 1219961, 1820526  (xmin, xmax, ymin, ymax) #> coord. ref. : +proj=aea +lat_0=23 +lon_0=-96 +lat_1=29.5 +lat_2=45.5 +x_0=0 +y_0=0 +datum=NAD83 +units=m +no_defs  #> source(s)   : memory #> name        : file928c3830468b  #> min value   :        -3589.291  #> max value   :         1946.400 plot(srtm) terra::crs(srtm) <- \"EPSG:5070\" ncpoints_tr <- terra::vect(ncpoints) system.time(     ncpoints_srtm <-         chopin::extract_with(             vector = ncpoints_tr,             raster = srtm,             id = \"pid\",             mode = \"buffer\",             radius = 1e4L) # 10,000 meters (10 km) ) #>    user  system elapsed  #>   6.271   0.210   6.484"},{"path":"/index.html","id":"generate-regular-grid-computational-regions","dir":"","previous_headings":"","what":"Generate regular grid computational regions","title":"CHOPIN: Computation for Climate and Health research On Parallelized\n    INfrastructure","text":"chopin::get_computational_regions takes locations generate regular grid polygons nx ny arguments padding. Users overlapping (degree radius) non-overlapping grids, utilized split locations target datasets sub-datasets efficient processing. compregions object two elements named original (non-overlapping grid polygons) padded (overlapping padding). figures illustrate grid polygons without overlaps.","code":"compregions <-     chopin::get_computational_regions(         ncpoints_tr,         mode = \"grid\",         nx = 8L,         ny = 5L,         padding = 1e4L     ) names(compregions) #> [1] \"original\" \"padded\"  oldpar <- par() par(mfcol = c(1, 2)) plot(compregions$original, main = \"Original grids\") plot(compregions$padded, main = \"Padded grids\") par(oldpar)"},{"path":"/index.html","id":"parallel-processing","dir":"","previous_headings":"","what":"Parallel processing","title":"CHOPIN: Computation for Climate and Health research On Parallelized\n    INfrastructure","text":"Using grid polygons, distribute task averaging elevations 10,000 circular buffer polygons, generated random locations, 10 kilometers radius chopin::distribute_process_grid Users always need register multiple CPU threads (logical cores) enable used R processes. Users can inject generic functions’ arguments (parameters) writing ellipsis arguments, like : ``` r plan(multicore, workers = 4L) doFuture::registerDoFuture() system.time( ncpoints_srtm_mthr <- chopin::distribute_process_grid( grids = compregions, grid_target_id = NULL, fun_dist = chopin::extract_with, vector = ncpoints_tr, raster = srtm, id = “pid”, mode = “buffer”, radius = 1e4L ) ) #> input function #> successfully run CGRIDID: 1 #> input function #> successfully run CGRIDID: 2 #> input function #> successfully run CGRIDID: 3 #> input function #> successfully run CGRIDID: 4 #> input function #> successfully run CGRIDID: 5 #> input function #> successfully run CGRIDID: 6 #> input function #> successfully run CGRIDID: 7 #> input function #> successfully run CGRIDID: 8 #> input function #> successfully run CGRIDID: 9 #> input function #> successfully run CGRIDID: 10 #> input function #> successfully run CGRIDID: 11 #> input function #> successfully run CGRIDID: 12 #> input function #> successfully run CGRIDID: 13 #> input function #> successfully run CGRIDID: 14 #> input function #> successfully run CGRIDID: 15 #> input function #> successfully run CGRIDID: 16 #> input function #> successfully run CGRIDID: 17 #> input function #> successfully run CGRIDID: 18 #> input function #> successfully run CGRIDID: 19 #> input function #> successfully run CGRIDID: 20 #> input function #> successfully run CGRIDID: 21 #> input function #> successfully run CGRIDID: 22 #> input function #> successfully run CGRIDID: 23 #> input function #> successfully run CGRIDID: 24 #> input function #> successfully run CGRIDID: 25 #> input function #> successfully run CGRIDID: 26 #> input function #> successfully run CGRIDID: 27 #> input function #> successfully run CGRIDID: 28 #> input function #> successfully run CGRIDID: 29 #> input function #> successfully run CGRIDID: 30 #> input function #> successfully run CGRIDID: 31 #> input function #> successfully run CGRIDID: 32 #> input function #> successfully run CGRIDID: 33 #> user system elapsed #> 4.407 0.351 2.438","code":"``` r ncpoints_srtm_mthr <-     ncpoints_srtm_mthr[order(ncpoints_srtm_mthr$pid),] all.equal(ncpoints_srtm, ncpoints_srtm_mthr) #> [1] \"Attributes: < Component \\\"row.names\\\": Mean relative difference: 0.6567904 >\" #> [2] \"Component \\\"mean\\\": Mean relative difference: 8.712634e-05\" ncpoints_s <-     merge(ncpoints, ncpoints_srtm) ncpoints_m <-     merge(ncpoints, ncpoints_srtm_mthr)  plot(ncpoints_s[, \"mean\"], main = \"Single-thread\") plot(ncpoints_m[, \"mean\"], main = \"Multi-thread\")"},{"path":"/index.html","id":"parallelize-geospatial-computations-using-intrinsic-data-hierarchy-chopindistribute_process_hierarchy","dir":"","previous_headings":"","what":"Parallelize geospatial computations using intrinsic data hierarchy: chopin::distribute_process_hierarchy","title":"CHOPIN: Computation for Climate and Health research On Parallelized\n    INfrastructure","text":"real world datasets, usually nested/exhaustive hierarchies. example, land organized administrative/jurisdictional borders multiple levels exist. U.S. context, state consists several counties, counties split census tracts, group block groups. chopin::distribute_process_hierarchy leverages hierarchies parallelize geospatial operations, means group lower-level geographic units higher-level geography assigned process. demonstration shows census tracts grouped counties county processed CPU thread.","code":"nc_county <- file.path(\"../testdata/nc_hierarchy.gpkg\") nc_county <- sf::st_read(nc_county, layer = \"county\") #> Reading layer `county' from data source  #>   `/Users/songi2/Documents/GitHub/Scalable_GIS/tools/testdata/nc_hierarchy.gpkg'  #>   using driver `GPKG' #> Simple feature collection with 100 features and 1 field #> Geometry type: POLYGON #> Dimension:     XY #> Bounding box:  xmin: 1054155 ymin: 1341756 xmax: 1838923 ymax: 1690176 #> Projected CRS: NAD83 / Conus Albers  nc_tracts <- file.path(\"../testdata/nc_hierarchy.gpkg\") nc_tracts <- sf::st_read(nc_tracts, layer = \"tracts\") #> Reading layer `tracts' from data source  #>   `/Users/songi2/Documents/GitHub/Scalable_GIS/tools/testdata/nc_hierarchy.gpkg'  #>   using driver `GPKG' #> Simple feature collection with 2672 features and 1 field #> Geometry type: MULTIPOLYGON #> Dimension:     XY #> Bounding box:  xmin: 1054155 ymin: 1341756 xmax: 1838923 ymax: 1690176 #> Projected CRS: NAD83 / Conus Albers  nc_county <- sf::st_transform(nc_county, \"EPSG:5070\") nc_tracts <- sf::st_transform(nc_tracts, \"EPSG:5070\") nc_tracts$COUNTY <-     substr(nc_tracts$GEOID, 1, 5) system.time(     nc_elev_tr_single <- chopin::extract_with(         vector = nc_tracts,         raster = srtm,         id = \"GEOID\",         mode = \"polygon\"     ) ) #>    user  system elapsed  #>   1.082   0.021   1.102 system.time(     nc_elev_tr_distr <-         chopin::distribute_process_hierarchy(             regions = nc_county, # higher level geometry             split_level = \"GEOID\", # higher level unique id             fun_dist = chopin::extract_with,             vector = nc_tracts, # lower level geometry             raster = srtm,             id = \"GEOID\", # lower level unique id             func = \"mean\"         ) ) #>    user  system elapsed  #>   0.023   0.013   1.317"},{"path":"/index.html","id":"multiple-rasters","dir":"","previous_headings":"","what":"Multiple rasters","title":"CHOPIN: Computation for Climate and Health research On Parallelized\n    INfrastructure","text":"common case large group raster files operation performed. chopin::distribute_process_multirasters cases. example demonstrates five elevation raster files calculate average elevation counties North Carolina.","code":"ncpath <- \"../testdata/nc_hierarchy.gpkg\" nccnty <- terra::vect(ncpath, layer = \"county\") ncelev <- terra::unwrap(readRDS(\"../testdata/nc_srtm15_otm.rds\")) terra::crs(ncelev) <- \"EPSG:5070\" names(ncelev) <- c(\"srtm15\") tdir <- tempdir() terra::writeRaster(ncelev, file.path(tdir, \"test1.tif\"), overwrite = TRUE) terra::writeRaster(ncelev, file.path(tdir, \"test2.tif\"), overwrite = TRUE) terra::writeRaster(ncelev, file.path(tdir, \"test3.tif\"), overwrite = TRUE) terra::writeRaster(ncelev, file.path(tdir, \"test4.tif\"), overwrite = TRUE) terra::writeRaster(ncelev, file.path(tdir, \"test5.tif\"), overwrite = TRUE)  testfiles <- list.files(tempdir(), pattern = \"*.tif$\", full.names = TRUE) testfiles #> [1] \"/var/folders/58/7rn_bn5d6k3_cxwnzdhswpz4n0z2n9/T//RtmpUJwWlN/test1.tif\" #> [2] \"/var/folders/58/7rn_bn5d6k3_cxwnzdhswpz4n0z2n9/T//RtmpUJwWlN/test2.tif\" #> [3] \"/var/folders/58/7rn_bn5d6k3_cxwnzdhswpz4n0z2n9/T//RtmpUJwWlN/test3.tif\" #> [4] \"/var/folders/58/7rn_bn5d6k3_cxwnzdhswpz4n0z2n9/T//RtmpUJwWlN/test4.tif\" #> [5] \"/var/folders/58/7rn_bn5d6k3_cxwnzdhswpz4n0z2n9/T//RtmpUJwWlN/test5.tif\" res <- distribute_process_multirasters(       filenames = testfiles,       fun_dist = extract_with_polygons,       polys = nccnty,       surf = ncelev,       id = \"GEOID\",       func = \"mean\"     )  knitr::kable(head(res))"},{"path":"/index.html","id":"parallelization-of-a-generic-geospatial-operation","dir":"","previous_headings":"","what":"Parallelization of a generic geospatial operation","title":"CHOPIN: Computation for Climate and Health research On Parallelized\n    INfrastructure","text":"chopin internal macros, chopin::distribute_process_* functions support generic geospatial operations. example uses terra::nearest, gets nearest feature’s attributes, inside chopin::distribute_process_grid.","code":"pnts <- readRDS(\"../testdata/nc_random_point.rds\") pnts <- terra::vect(pnts) rd1 <- terra::vect(     file.path(\"../testdata/ncroads_first.gpkg\"))  pnts <- terra::project(pnts, \"EPSG:5070\") rd1 <- terra::project(rd1, \"EPSG:5070\")   nccompreg <-     get_computational_regions(                               input = pnts,                               mode = \"grid\",                               nx = 6L,                               ny = 4L,                               padding = 3e4L)    future::plan(future::multicore, workers = 6L)  system.time( res <-   distribute_process_grid(                           grids = nccompreg,                           fun_dist = terra::nearest,                           x = pnts,                           y = rd1) ) #> Your input function was  #>             successfully run at CGRIDID: 1 #> Your input function was  #>             successfully run at CGRIDID: 2 #> Your input function was  #>             successfully run at CGRIDID: 3 #> Your input function was  #>             successfully run at CGRIDID: 4 #> Your input function was  #>             successfully run at CGRIDID: 5 #> Your input function was  #>             successfully run at CGRIDID: 6 #> Your input function was  #>             successfully run at CGRIDID: 7 #> Your input function was  #>             successfully run at CGRIDID: 8 #> Your input function was  #>             successfully run at CGRIDID: 9 #> Your input function was  #>             successfully run at CGRIDID: 10 #> Your input function was  #>             successfully run at CGRIDID: 11 #> Your input function was  #>             successfully run at CGRIDID: 12 #> Your input function was  #>             successfully run at CGRIDID: 13 #> Your input function was  #>             successfully run at CGRIDID: 14 #> Your input function was  #>             successfully run at CGRIDID: 15 #> Your input function was  #>             successfully run at CGRIDID: 16 #> Your input function was  #>             successfully run at CGRIDID: 17 #> Your input function was  #>             successfully run at CGRIDID: 18 #> Your input function was  #>             successfully run at CGRIDID: 19 #> Your input function was  #>             successfully run at CGRIDID: 20 #>    user  system elapsed  #>   0.366   0.265   0.173    system.time(   restr <- terra::nearest(x = pnts, y = rd1) ) #>    user  system elapsed  #>   0.036   0.000   0.036"},{"path":"/index.html","id":"why-parallelization-is-slower-than-the-ordinary-function-run","dir":"","previous_headings":"","what":"Why parallelization is slower than the ordinary function run?","title":"CHOPIN: Computation for Climate and Health research On Parallelized\n    INfrastructure","text":"Parallelization may underperform datasets small take advantage divide--compute approach, parallelization overhead involved. Overhead refers required amount computational resources transferring objects multiple processes. Since demonstrations use quite small datasets, advantage parallelization dramatically expected. large amount data (spatial/temporal resolution number files, example) processed, users see efficiency package. illustrative truly scaled examples added vignette soon.","code":""},{"path":[]},{"path":"/reference/aw_covariates.html","id":null,"dir":"Reference","previous_headings":"","what":"Computing area weighted covariates using two polygon sf or SpatVector objects — aw_covariates","title":"Computing area weighted covariates using two polygon sf or SpatVector objects — aw_covariates","text":"poly_in poly_weight different classes, poly_weight converted class poly_in.","code":""},{"path":"/reference/aw_covariates.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Computing area weighted covariates using two polygon sf or SpatVector objects — aw_covariates","text":"","code":"aw_covariates(poly_in, poly_weight, id_poly_in = \"ID\")"},{"path":"/reference/aw_covariates.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Computing area weighted covariates using two polygon sf or SpatVector objects — aw_covariates","text":"poly_in sf/SpatVector object weighted means calculated. poly_weight sf/SpatVector object weighted means calculated. id_poly_in character(1). unique identifier polygon poly_in","code":""},{"path":"/reference/aw_covariates.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Computing area weighted covariates using two polygon sf or SpatVector objects — aw_covariates","text":"data.frame numeric fields area-weighted means.","code":""},{"path":"/reference/aw_covariates.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Computing area weighted covariates using two polygon sf or SpatVector objects — aw_covariates","text":"Insang Song geoissong@gmail.com","code":""},{"path":"/reference/aw_covariates.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Computing area weighted covariates using two polygon sf or SpatVector objects — aw_covariates","text":"","code":"# package library(sf) #> Linking to GEOS 3.10.2, GDAL 3.4.1, PROJ 8.2.1; sf_use_s2() is TRUE  # run nc <- sf::st_read(system.file(\"shape/nc.shp\", package=\"sf\")) #> Reading layer `nc' from data source  #>   `/home/runner/work/_temp/Library/sf/shape/nc.shp' using driver `ESRI Shapefile' #> Simple feature collection with 100 features and 14 fields #> Geometry type: MULTIPOLYGON #> Dimension:     XY #> Bounding box:  xmin: -84.32385 ymin: 33.88199 xmax: -75.45698 ymax: 36.58965 #> Geodetic CRS:  NAD27 nc <- sf::st_transform(nc, 5070) pp <- sf::st_sample(nc, size = 300) pp <- sf::st_as_sf(pp) pp[[\"id\"]] <- seq(1, nrow(pp)) sf::st_crs(pp) <- \"EPSG:5070\" ppb <- sf::st_buffer(pp, nQuadSegs=180, dist = units::set_units(20, 'km'))  system.time({ppb_nc_aw <- aw_covariates(ppb, nc, 'id')}) #>    user  system elapsed  #>   0.350   0.008   0.358  summary(ppb_nc_aw) #>       AREA           PERIMETER         CNTY_         CNTY_ID     #>  Min.   :0.05832   Min.   :1.117   Min.   :1825   Min.   :1825   #>  1st Qu.:0.11831   1st Qu.:1.521   1st Qu.:1909   1st Qu.:1909   #>  Median :0.13572   Median :1.707   Median :1999   Median :1999   #>  Mean   :0.14448   Mean   :1.795   Mean   :2000   Mean   :2000   #>  3rd Qu.:0.16716   3rd Qu.:1.979   3rd Qu.:2081   3rd Qu.:2081   #>  Max.   :0.24098   Max.   :3.640   Max.   :2241   Max.   :2241   #>      FIPSNO         CRESS_ID         BIR74             SID74        #>  Min.   :37009   Min.   : 4.95   Min.   :  327.6   Min.   : 0.000   #>  1st Qu.:37066   1st Qu.:33.70   1st Qu.: 1759.6   1st Qu.: 3.536   #>  Median :37101   Median :50.77   Median : 2874.0   Median : 6.149   #>  Mean   :37096   Mean   :48.62   Mean   : 3638.0   Mean   : 7.718   #>  3rd Qu.:37124   3rd Qu.:62.51   3rd Qu.: 4294.2   3rd Qu.:10.230   #>  Max.   :37185   Max.   :93.12   Max.   :18633.8   Max.   :37.249   #>     NWBIR74             BIR79             SID79           NWBIR79       #>  Min.   :   3.483   Min.   :  417.5   Min.   : 0.000   Min.   :   3.0   #>  1st Qu.: 426.540   1st Qu.: 2134.0   1st Qu.: 4.190   1st Qu.: 558.4   #>  Median : 938.207   Median : 3573.8   Median : 7.945   Median :1169.7   #>  Mean   :1199.588   Mean   : 4672.2   Mean   : 9.152   Mean   :1550.4   #>  3rd Qu.:1655.214   3rd Qu.: 5367.0   3rd Qu.:12.389   3rd Qu.:2080.6   #>  Max.   :6846.306   Max.   :26502.3   Max.   :52.022   Max.   :9900.0   #>           geometry   #>  POLYGON      :300   #>  epsg:5070    :  0   #>  +proj=aea ...:  0   #>                      #>                      #>                      #### Example of aw_covariates ends ####"},{"path":"/reference/calculate_sedc.html","id":null,"dir":"Reference","previous_headings":"","what":"Calculate SEDC covariates — calculate_sedc","title":"Calculate SEDC covariates — calculate_sedc","text":"Calculate SEDC covariates","code":""},{"path":"/reference/calculate_sedc.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Calculate SEDC covariates — calculate_sedc","text":"","code":"calculate_sedc(   point_from,   point_to,   id,   sedc_bandwidth,   threshold,   target_fields )"},{"path":"/reference/calculate_sedc.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Calculate SEDC covariates — calculate_sedc","text":"point_from SpatVector object. Locations sum SEDCs calculated. point_to SpatVector object. Locations SEDC calculated. id character(1). Name unique id field point_to. sedc_bandwidth numeric(1). Distance source concentration reduced exp(-3) (approximately -95 %) threshold numeric(1). computational efficiency, nearest points threshold selected. Default 2 * sedc_bandwidth. target_fields character(varying). Field names characters.","code":""},{"path":"/reference/calculate_sedc.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Calculate SEDC covariates — calculate_sedc","text":"data.frame (tibble) object input field names suffix \"_sedc\" sums EDC stored. Additional attributes attached EDC information. attr(result, \"sedc_bandwidth\"): bandwidth concentration reduces approximately five percent attr(result, \"sedc_threshold\"): threshold distance emission source points excluded beyond ","code":""},{"path":"/reference/calculate_sedc.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Calculate SEDC covariates — calculate_sedc","text":"Distance calculation done terra functions internally. Thus, function internally converts sf objects point_* arguments terra. optimal EDC carefully chosen users.","code":""},{"path":"/reference/calculate_sedc.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Calculate SEDC covariates — calculate_sedc","text":"Insang Song","code":""},{"path":"/reference/check_bbox.html","id":null,"dir":"Reference","previous_headings":"","what":"Check if the data extent is inside the reference bounding box — check_bbox","title":"Check if the data extent is inside the reference bounding box — check_bbox","text":"One common errors spatial computation rooted entirely partly incomparable spatial extents input datasets. function returns whether data inside target computational extent. assumed know exact computational region. function return TRUE reference region completely contains data's extent FALSE otherwise.","code":""},{"path":"/reference/check_bbox.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Check if the data extent is inside the reference bounding box — check_bbox","text":"","code":"check_bbox(data_query, reference)"},{"path":"/reference/check_bbox.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Check if the data extent is inside the reference bounding box — check_bbox","text":"data_query sf*/stars/SpatVector/SpatRaster object. reference sf*/stars/SpatVector/SpatRaster object","code":""},{"path":"/reference/check_bbox.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Check if the data extent is inside the reference bounding box — check_bbox","text":"TRUE (queried data extent completely within reference bounding box) FALSE","code":""},{"path":"/reference/check_bbox.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Check if the data extent is inside the reference bounding box — check_bbox","text":"Insang Song geoissong@gmail.com","code":""},{"path":"/reference/check_crs.html","id":null,"dir":"Reference","previous_headings":"","what":"Check Coordinate Reference System — check_crs","title":"Check Coordinate Reference System — check_crs","text":"returns st_crs object sf/Spat* objects.","code":""},{"path":"/reference/check_crs.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Check Coordinate Reference System — check_crs","text":"","code":"check_crs(x)"},{"path":"/reference/check_crs.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Check Coordinate Reference System — check_crs","text":"x sf/stars/SpatVector/SpatRaster object.","code":""},{"path":"/reference/check_crs.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Check Coordinate Reference System — check_crs","text":"st_crs crs object.","code":""},{"path":"/reference/check_crs.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Check Coordinate Reference System — check_crs","text":"Insang Song geoissong@gmail.com","code":""},{"path":"/reference/check_crs.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Check Coordinate Reference System — check_crs","text":"","code":"# data library(sf) ncpath = system.file(\"shape/nc.shp\", package = \"sf\") nc = read_sf(ncpath) check_crs(nc) #> Coordinate Reference System: #>   User input: NAD27  #>   wkt: #> GEOGCRS[\"NAD27\", #>     DATUM[\"North American Datum 1927\", #>         ELLIPSOID[\"Clarke 1866\",6378206.4,294.978698213898, #>             LENGTHUNIT[\"metre\",1]]], #>     PRIMEM[\"Greenwich\",0, #>         ANGLEUNIT[\"degree\",0.0174532925199433]], #>     CS[ellipsoidal,2], #>         AXIS[\"latitude\",north, #>             ORDER[1], #>             ANGLEUNIT[\"degree\",0.0174532925199433]], #>         AXIS[\"longitude\",east, #>             ORDER[2], #>             ANGLEUNIT[\"degree\",0.0174532925199433]], #>     ID[\"EPSG\",4267]]"},{"path":"/reference/check_crs_align.html","id":null,"dir":"Reference","previous_headings":"","what":"check_crs_align: Check coordinate system then reproject — check_crs_align","title":"check_crs_align: Check coordinate system then reproject — check_crs_align","text":"input checked whether coordinate system present. , reprojected CRS specified crs_standard.","code":""},{"path":"/reference/check_crs_align.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"check_crs_align: Check coordinate system then reproject — check_crs_align","text":"","code":"check_crs_align(input, crs_standard = \"EPSG:4326\")"},{"path":"/reference/check_crs_align.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"check_crs_align: Check coordinate system then reproject — check_crs_align","text":"input Input object one sf terra::Spat* object crs_standard character(1). standard definition coordinate reference system. Default \"EPSG:4326\" Consult epsg.io details CRS.","code":""},{"path":"/reference/check_crs_align.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"check_crs_align: Check coordinate system then reproject — check_crs_align","text":"(reprojected) sf SpatVector object.","code":""},{"path":"/reference/check_datatype.html","id":null,"dir":"Reference","previous_headings":"","what":"Return the data type — check_datatype","title":"Return the data type — check_datatype","text":"function returns one 'vector' 'raster' depending input class.","code":""},{"path":"/reference/check_datatype.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Return the data type — check_datatype","text":"","code":"check_datatype(input)"},{"path":"/reference/check_datatype.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Return the data type — check_datatype","text":"input Spat*/sf/stars object.","code":""},{"path":"/reference/check_datatype.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Return the data type — check_datatype","text":"character(1). One 'vector' 'raster'.","code":""},{"path":"/reference/check_datatype.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Return the data type — check_datatype","text":"stars object tricky little whether classify vector raster. package, stars object considered raster.","code":""},{"path":"/reference/check_datatype.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Return the data type — check_datatype","text":"Insang song","code":""},{"path":"/reference/check_packbound.html","id":null,"dir":"Reference","previous_headings":"","what":"Return the package the input object is based on — check_packbound","title":"Return the package the input object is based on — check_packbound","text":"Detect whether input object sf Spat* object.","code":""},{"path":"/reference/check_packbound.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Return the package the input object is based on — check_packbound","text":"","code":"check_packbound(input)"},{"path":"/reference/check_packbound.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Return the package the input object is based on — check_packbound","text":"input Spat* terra sf object.","code":""},{"path":"/reference/check_packbound.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Return the package the input object is based on — check_packbound","text":"character object; one 'terra' 'sf'","code":""},{"path":"/reference/check_packbound.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Return the package the input object is based on — check_packbound","text":"Insang Song","code":""},{"path":"/reference/check_within_reference.html","id":null,"dir":"Reference","previous_headings":"","what":"Check if the boundary of the vector/raster object is inside the reference — check_within_reference","title":"Check if the boundary of the vector/raster object is inside the reference — check_within_reference","text":"Check boundary vector/raster object inside reference","code":""},{"path":"/reference/check_within_reference.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Check if the boundary of the vector/raster object is inside the reference — check_within_reference","text":"","code":"check_within_reference(input_object, reference)"},{"path":"/reference/check_within_reference.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Check if the boundary of the vector/raster object is inside the reference — check_within_reference","text":"input_object sf/stars/SpatVector/SpatRaster object. reference sf/stars/SpatVector/SpatRaster object.","code":""},{"path":"/reference/check_within_reference.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Check if the boundary of the vector/raster object is inside the reference — check_within_reference","text":"logical","code":""},{"path":"/reference/check_within_reference.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Check if the boundary of the vector/raster object is inside the reference — check_within_reference","text":"Insang Song geoissong@gmail.com","code":""},{"path":"/reference/clip_as_extent.html","id":null,"dir":"Reference","previous_headings":"","what":"Extent clipping — clip_as_extent","title":"Extent clipping — clip_as_extent","text":"Clip input vector expected maximum extent computation.","code":""},{"path":"/reference/clip_as_extent.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Extent clipping — clip_as_extent","text":"","code":"clip_as_extent(pnts, buffer_r, target_input)"},{"path":"/reference/clip_as_extent.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Extent clipping — clip_as_extent","text":"pnts sf SpatVector object buffer_r numeric(1). buffer radius. value automatically multiplied 1.25 target_input sf SpatVector object clipped","code":""},{"path":"/reference/clip_as_extent.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Extent clipping — clip_as_extent","text":"clipped sf SpatVector object.","code":""},{"path":"/reference/clip_as_extent.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Extent clipping — clip_as_extent","text":"Insang Song","code":""},{"path":"/reference/clip_as_extent_ras.html","id":null,"dir":"Reference","previous_headings":"","what":"clip_as_extent_ras: Clip input raster. — clip_as_extent_ras","title":"clip_as_extent_ras: Clip input raster. — clip_as_extent_ras","text":"Clip input raster expected maximum extent computation.","code":""},{"path":"/reference/clip_as_extent_ras.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"clip_as_extent_ras: Clip input raster. — clip_as_extent_ras","text":"","code":"clip_as_extent_ras(pnts, buffer_r, ras, nqsegs = 180L)"},{"path":"/reference/clip_as_extent_ras.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"clip_as_extent_ras: Clip input raster. — clip_as_extent_ras","text":"pnts sf SpatVector object buffer_r numeric(1). buffer radius. value automatically multiplied 1.25 ras SpatRaster object clipped nqsegs integer(1). number points per quarter circle","code":""},{"path":"/reference/clip_as_extent_ras.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"clip_as_extent_ras: Clip input raster. — clip_as_extent_ras","text":"Insang Song","code":""},{"path":"/reference/detect_class.html","id":null,"dir":"Reference","previous_headings":"","what":"Detect classes in function arguments — detect_class","title":"Detect classes in function arguments — detect_class","text":"R function defined ordinary fashion (.e., assigning function <- function(...)) subject ambiguity particularly function name generic function name(s). function supports detecting classes arguments loosely defined function.","code":""},{"path":"/reference/detect_class.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Detect classes in function arguments — detect_class","text":"","code":"detect_class(args, search)"},{"path":"/reference/detect_class.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Detect classes in function arguments — detect_class","text":"args list, preferably generated list(...) inside function. search character(1). Class name search. Partial match supported.","code":""},{"path":"/reference/detect_class.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Detect classes in function arguments — detect_class","text":"logical vector.","code":""},{"path":"/reference/detect_class.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Detect classes in function arguments — detect_class","text":"Insang Song","code":""},{"path":"/reference/distribute_process_grid.html","id":null,"dir":"Reference","previous_headings":"","what":"Process a given function in the entire or partial computational grids — distribute_process_grid","title":"Process a given function in the entire or partial computational grids — distribute_process_grid","text":"Currently accepting multicore setting (single node, single process, multiple threads). details terminology future package, refer plan. function assumes users one raster file sizable spatially distributed target locations. thread process ceiling(|Ng|/|Nt|) grids |Ng| denotes number grids |Nt| denotes number threads.","code":""},{"path":"/reference/distribute_process_grid.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Process a given function in the entire or partial computational grids — distribute_process_grid","text":"","code":"distribute_process_grid(   grids,   grid_target_id = NULL,   debug = FALSE,   fun_dist,   ... )"},{"path":"/reference/distribute_process_grid.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Process a given function in the entire or partial computational grids — distribute_process_grid","text":"grids sf/SpatVector object. Computational grids. takes strict assumption grid input output get_computational_regions grid_target_id character(1) numeric(2). Default NULL. NULL, grid_ids used. \"id_from:id_to\" format c(unique(grid_id)[id_from], unique(grid_id)[id_to]) debug logical(1). Prints error messages errors calculation. fun_dist sf, terra chopin functions. ... Arguments passed argument fun_dist.","code":""},{"path":"/reference/distribute_process_grid.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Process a given function in the entire or partial computational grids — distribute_process_grid","text":"data.frame object computation results. entries results, consult function used fun_dist argument.","code":""},{"path":"/reference/distribute_process_grid.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Process a given function in the entire or partial computational grids — distribute_process_grid","text":"dynamic dots (...), first second arguments fun_dist arguments sf/SpatVector objects accepted. Virtually sf/terra functions accept two arguments can put fun_dist, please advised spatial operations necessarily give exact result done single-thread. example, distance calculated function may return lower value actual computational region reduced. case especially target features spatially sparsely distributed.","code":""},{"path":"/reference/distribute_process_grid.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Process a given function in the entire or partial computational grids — distribute_process_grid","text":"Insang Song geoissong@gmail.com","code":""},{"path":"/reference/distribute_process_grid.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Process a given function in the entire or partial computational grids — distribute_process_grid","text":"","code":"library(future) plan(multicore, workers = 4) # Does not run ... # distribute_process_grid()"},{"path":"/reference/distribute_process_hierarchy.html","id":null,"dir":"Reference","previous_headings":"","what":"Process a given function using a hierarchy in input data — distribute_process_hierarchy","title":"Process a given function using a hierarchy in input data — distribute_process_hierarchy","text":"\"Hierarchy\" refers system, divides entire study region multiple subregions. oftentimes reflected area code system (e.g., FIPS US Census geographies, HUC-4, -6, -8, etc.). Currently accepting multicore setting (single node, single process, multiple threads). details terminology future package, refer plan. function assumes users one raster file sizable spatially distributed target locations. thread process ceiling(|Ng|/|Nt|) grids |Ng| denotes number grids |Nt| denotes number threads. Please advised accessing file simultaneously multiple processes may result errors.","code":""},{"path":"/reference/distribute_process_hierarchy.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Process a given function using a hierarchy in input data — distribute_process_hierarchy","text":"","code":"distribute_process_hierarchy(   regions,   split_level = NULL,   debug = FALSE,   fun_dist,   ... )"},{"path":"/reference/distribute_process_hierarchy.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Process a given function using a hierarchy in input data — distribute_process_hierarchy","text":"regions sf/SpatVector object. Computational regions. polygons accepted. split_level character(nrow(regions)) character(1). regions split common level value. level higher original data level. field name higher level information also accepted. debug logical(1). Prints error messages errors calculation. fun_dist sf, terra, chopin functions. ... Arguments passed argument fun_dist.","code":""},{"path":"/reference/distribute_process_hierarchy.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Process a given function using a hierarchy in input data — distribute_process_hierarchy","text":"data.frame object computation results. entries results, consult function used fun_dist argument.","code":""},{"path":"/reference/distribute_process_hierarchy.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Process a given function using a hierarchy in input data — distribute_process_hierarchy","text":"dynamic dots (...), first second arguments fun_dist arguments sf/SpatVector objects accepted. Virtually sf/terra functions accept two arguments can put fun_dist, please advised spatial operations necessarily give exact result done single-thread. example, distance calculated function may return lower value actual computational region reduced. case especially target features spatially sparsely distributed.","code":""},{"path":"/reference/distribute_process_hierarchy.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Process a given function using a hierarchy in input data — distribute_process_hierarchy","text":"Insang Song geoissong@gmail.com","code":""},{"path":"/reference/distribute_process_hierarchy.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Process a given function using a hierarchy in input data — distribute_process_hierarchy","text":"","code":"library(future) plan(multicore, workers = 4) # Does not run ... # distribute_process_hierarchy()"},{"path":"/reference/distribute_process_multirasters.html","id":null,"dir":"Reference","previous_headings":"","what":"Process a given function over multiple large rasters — distribute_process_multirasters","title":"Process a given function over multiple large rasters — distribute_process_multirasters","text":"Large raster files usually exceed memory capacity size. Cropping large raster small subset even consumes lot memory adds processing time. function leverages terra SpatRaster proxy distribute computation jobs multiple cores. assumed users multiple large raster files disk, file path assigned thread. thread directly read raster values disk using C++ pointers operate terra functions. use, strongly recommended use vector data small confined spatial extent computation avoid --memory error. , users may need make subsets input vector objects advance.","code":""},{"path":"/reference/distribute_process_multirasters.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Process a given function over multiple large rasters — distribute_process_multirasters","text":"","code":"distribute_process_multirasters(filenames, debug = FALSE, fun_dist, ...)"},{"path":"/reference/distribute_process_multirasters.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Process a given function over multiple large rasters — distribute_process_multirasters","text":"filenames character(n). vector list full file paths raster files. n total number raster files. debug logical(1). Prints error messages errors calculation. fun_dist sf, terra, chopin functions. ... Arguments passed argument fun_dist.","code":""},{"path":"/reference/distribute_process_multirasters.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Process a given function over multiple large rasters — distribute_process_multirasters","text":"data.frame object computation results. entries results, consult function used fun_dist argument.","code":""},{"path":"/reference/distribute_process_multirasters.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Process a given function over multiple large rasters — distribute_process_multirasters","text":"Insang Song geoissong@gmail.com","code":""},{"path":"/reference/distribute_process_multirasters.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Process a given function over multiple large rasters — distribute_process_multirasters","text":"","code":"library(future) plan(multicore, workers = 4) # Does not run ... # distribute_process_multirasters()"},{"path":"/reference/estimate_demands.html","id":null,"dir":"Reference","previous_headings":"","what":"Estimate computational demands from inputs (to be written) — estimate_demands","title":"Estimate computational demands from inputs (to be written) — estimate_demands","text":"Estimate computational demands inputs (written)","code":""},{"path":"/reference/estimate_demands.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Estimate computational demands from inputs (to be written) — estimate_demands","text":"","code":"estimate_demands(inputs, nx, ny, padding)"},{"path":"/reference/estimate_demands.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Estimate computational demands from inputs (to be written) — estimate_demands","text":"inputs character vector file paths nx integer(1). ny integer(1). padding numeric(1). Extrusion factor","code":""},{"path":"/reference/estimate_demands.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Estimate computational demands from inputs (to be written) — estimate_demands","text":"Insang Song","code":""},{"path":"/reference/extent_to_polygon.html","id":null,"dir":"Reference","previous_headings":"","what":"Generate a rectangular polygon from extent — extent_to_polygon","title":"Generate a rectangular polygon from extent — extent_to_polygon","text":"Generate rectangular polygon extent","code":""},{"path":"/reference/extent_to_polygon.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Generate a rectangular polygon from extent — extent_to_polygon","text":"","code":"extent_to_polygon(extent, output_class = \"terra\", crs = \"EPSG:4326\")"},{"path":"/reference/extent_to_polygon.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Generate a rectangular polygon from extent — extent_to_polygon","text":"extent input extent. numeric vector xmin/xmax/ymin/ymax, sf::st_bbox() terra::ext() outputs. output_class character(1). Class output polygon. One \"sf\" \"terra\" crs character(1). Coordinate reference system definition.","code":""},{"path":"/reference/extent_to_polygon.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Generate a rectangular polygon from extent — extent_to_polygon","text":"Insang Song","code":""},{"path":"/reference/extract_with.html","id":null,"dir":"Reference","previous_headings":"","what":"Extract raster values with point buffers or polygons — extract_with","title":"Extract raster values with point buffers or polygons — extract_with","text":"Extract raster values point buffers polygons","code":""},{"path":"/reference/extract_with.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Extract raster values with point buffers or polygons — extract_with","text":"","code":"extract_with(   vector,   raster,   id,   func = \"mean\",   mode = c(\"polygon\", \"buffer\"),   ... )"},{"path":"/reference/extract_with.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Extract raster values with point buffers or polygons — extract_with","text":"vector sf/SpatVector object. raster SpatRaster object. id character(1). Unique identifier point. func function taking one numeric vector argument. mode one \"polygon\" (generic polygons extract raster values ) \"buffer\" (point buffer radius) ... various. Passed extract_with_buffer. See ?extract_with_buffer details.","code":""},{"path":"/reference/extract_with.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Extract raster values with point buffers or polygons — extract_with","text":"data.frame object summarized raster values respect mode (polygon buffer) function.","code":""},{"path":"/reference/extract_with.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Extract raster values with point buffers or polygons — extract_with","text":"Insang Song geoissong@gmail.com","code":""},{"path":"/reference/extract_with_buffer.html","id":null,"dir":"Reference","previous_headings":"","what":"Extract summarized values from raster with points and\na buffer radius (to be written) — extract_with_buffer","title":"Extract summarized values from raster with points and\na buffer radius (to be written) — extract_with_buffer","text":"simplicity, assumed coordinate systems points raster .","code":""},{"path":"/reference/extract_with_buffer.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Extract summarized values from raster with points and\na buffer radius (to be written) — extract_with_buffer","text":"","code":"extract_with_buffer(   points,   surf,   radius,   id,   qsegs = 90L,   func = \"mean\",   kernel = NULL,   bandwidth = NULL )"},{"path":"/reference/extract_with_buffer.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Extract summarized values from raster with points and\na buffer radius (to be written) — extract_with_buffer","text":"points sf/SpatVector object. Coordinates buffers generated surf SpatRaster object. raster whatnot summary calculated radius numeric(1). Buffer radius. assume circular buffers id character(1). Unique identifier point. qsegs integer(1). Number vertices quarter circle. Default 90. func function taking numeric vector argument. kernel character(1). Name kernel function One 'uniform', 'triweight', 'quartic', 'epanechnikov' bandwidth numeric(1). Kernel bandwidth.","code":""},{"path":"/reference/extract_with_buffer.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Extract summarized values from raster with points and\na buffer radius (to be written) — extract_with_buffer","text":"data.frame object mean value","code":""},{"path":"/reference/extract_with_buffer.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Extract summarized values from raster with points and\na buffer radius (to be written) — extract_with_buffer","text":"Insang Song geoissong@gmail.com","code":""},{"path":"/reference/extract_with_polygons.html","id":null,"dir":"Reference","previous_headings":"","what":"Extract summarized values from raster with generic polygons — extract_with_polygons","title":"Extract summarized values from raster with generic polygons — extract_with_polygons","text":"simplicity, assumed coordinate systems points raster . Kernel function yet implemented.","code":""},{"path":"/reference/extract_with_polygons.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Extract summarized values from raster with generic polygons — extract_with_polygons","text":"","code":"extract_with_polygons(polys, surf, id, func = \"mean\")"},{"path":"/reference/extract_with_polygons.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Extract summarized values from raster with generic polygons — extract_with_polygons","text":"polys sf/SpatVector object. Polygons. surf SpatRaster object. raster summary calculated id character(1). Unique identifier point. func generic function name string function taking two arguments compatible exact_extract. example, \"mean\" \\(x, w) weighted.mean(x, w, na.rm = TRUE)","code":""},{"path":"/reference/extract_with_polygons.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Extract summarized values from raster with generic polygons — extract_with_polygons","text":"data.frame object function value","code":""},{"path":"/reference/extract_with_polygons.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Extract summarized values from raster with generic polygons — extract_with_polygons","text":"Insang Song geoissong@gmail.com","code":""},{"path":"/reference/get_computational_regions.html","id":null,"dir":"Reference","previous_headings":"","what":"Get a set of computational regions — get_computational_regions","title":"Get a set of computational regions — get_computational_regions","text":"Using input points, bounding box split predefined numbers columns rows. grid buffered radius.","code":""},{"path":"/reference/get_computational_regions.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Get a set of computational regions — get_computational_regions","text":"","code":"get_computational_regions(   input,   mode = c(\"grid\", \"grid_advanced\", \"density\"),   nx = 10L,   ny = 10L,   grid_min_features = 30L,   padding = NULL,   unit = NULL,   ... )"},{"path":"/reference/get_computational_regions.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Get a set of computational regions — get_computational_regions","text":"input sf Spat* object. mode character(1). Mode region construction. One \"grid\" (simple grid regardless number features grid), \"density\" (clustering-based varying grids), \"grid_advanced\" (merging adjacent grids smaller number features grid_min_features). nx integer(1). number grids along x-axis. ny integer(1). number grids along y-axis. grid_min_features integer(1). threshold merging adjacent grids padding numeric(1). extrusion factor make buffer clip actual datasets. Depending length unit CRS input. unit character(1). length unit padding (optional). units::set_units used padding sf object used. See units package vignette (web) list acceptable unit forms. ... arguments passed internal function","code":""},{"path":"/reference/get_computational_regions.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Get a set of computational regions — get_computational_regions","text":"list two, original: exhaustive non-overlapping grid polygons class input padded: square buffer polygon original. Used computation.","code":""},{"path":"/reference/get_computational_regions.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Get a set of computational regions — get_computational_regions","text":"Insang Song","code":""},{"path":"/reference/get_computational_regions.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Get a set of computational regions — get_computational_regions","text":"","code":"# data library(sf) ncpath <- system.file(\"shape/nc.shp\", package = \"sf\") nc <- read_sf(ncpath) nc <- st_transform(nc, \"EPSG:5070\") # run # nc_comp_region <- get_computational_regions(nc, nx = 12, ny = 8)"},{"path":"/reference/grid_merge.html","id":null,"dir":"Reference","previous_headings":"","what":"grid_merge: Merge grid polygons with given rules — grid_merge","title":"grid_merge: Merge grid polygons with given rules — grid_merge","text":"Merge boundary-sharing (\"Rook\" contiguity) grids fewer target features threshold. function strongly assumes input returned sp_index_grid, 'CGRIDID' unique id field.","code":""},{"path":"/reference/grid_merge.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"grid_merge: Merge grid polygons with given rules — grid_merge","text":"","code":"grid_merge(points_in, grid_in, grid_min_features)"},{"path":"/reference/grid_merge.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"grid_merge: Merge grid polygons with given rules — grid_merge","text":"points_in sf SpatVector object. Target points computation. grid_in sf SpatVector object. grid generated sp_index_grid grid_min_features integer(1). Threshold merge adjacent grids.","code":""},{"path":"/reference/grid_merge.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"grid_merge: Merge grid polygons with given rules — grid_merge","text":"sf SpatVector object computation grids.","code":""},{"path":"/reference/grid_merge.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"grid_merge: Merge grid polygons with given rules — grid_merge","text":"Insang Song","code":""},{"path":"/reference/grid_merge.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"grid_merge: Merge grid polygons with given rules — grid_merge","text":"","code":"# library(sf) # library(igraph) # ligrary(dplyr) # dg <- sf::st_as_sfc(st_bbox(c(xmin = 0, ymin = 0, xmax = 8e5, ymax = 6e5))) # sf::st_crs(dg) <- 5070 # dgs <- sf::st_as_sf(st_make_grid(dg, n = c(20, 15))) # dgs$CGRIDID <- seq(1, nrow(dgs)) # # dg_sample <- st_sample(dg, kappa = 5e-9, mu = 15, # scale = 20000, type = \"Thomas\") # sf::st_crs(dg_sample) <- sf::st_crs(dg) # dg_merged <- grid_merge(sf::st_as_sf(sss), dgs, 100)  #### NOT RUN ####"},{"path":"/reference/kernelfunction.html","id":null,"dir":"Reference","previous_headings":"","what":"Kernel functions — kernelfunction","title":"Kernel functions — kernelfunction","text":"Kernel functions","code":""},{"path":"/reference/kernelfunction.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Kernel functions — kernelfunction","text":"","code":"kernelfunction(   d,   bw,   kernel = c(\"uniform\", \"quartic\", \"triweight\", \"epanechnikov\") )"},{"path":"/reference/kernelfunction.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Kernel functions — kernelfunction","text":"d Distance bw Bandwidth kernel kernel Kernel type. One 'uniform', 'quartic', 'triweight', 'epanechnikov'","code":""},{"path":"/reference/kernelfunction.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Kernel functions — kernelfunction","text":"SpatialKDE source","code":""},{"path":"/reference/prediction_grid.html","id":null,"dir":"Reference","previous_headings":"","what":"Regular grid points in the mainland United States at 1km spatial resolution — prediction_grid","title":"Regular grid points in the mainland United States at 1km spatial resolution — prediction_grid","text":"Regular grid points mainland United States 1km spatial resolution","code":""},{"path":"/reference/prediction_grid.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Regular grid points in the mainland United States at 1km spatial resolution — prediction_grid","text":"","code":"prediction_grid"},{"path":"/reference/prediction_grid.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Regular grid points in the mainland United States at 1km spatial resolution — prediction_grid","text":"data frame 8,092,995 rows three variables: site_id Unique point identifier. Arbitrarily generated. lon Longitude lat Latitude","code":""},{"path":"/reference/prediction_grid.html","id":"source","dir":"Reference","previous_headings":"","what":"Source","title":"Regular grid points in the mainland United States at 1km spatial resolution — prediction_grid","text":"Mainland United States polygon obtained US Census Bureau.","code":""},{"path":"/reference/prediction_grid.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Regular grid points in the mainland United States at 1km spatial resolution — prediction_grid","text":"Coordinates EPSG:5070 (Conus Albers Equal Area)","code":""},{"path":"/reference/rast_short.html","id":null,"dir":"Reference","previous_headings":"","what":"Quick call for SpatRaster with a window — rast_short","title":"Quick call for SpatRaster with a window — rast_short","text":"Quick call SpatRaster window","code":""},{"path":"/reference/rast_short.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Quick call for SpatRaster with a window — rast_short","text":"","code":"rast_short(rasterpath, win)"},{"path":"/reference/rast_short.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Quick call for SpatRaster with a window — rast_short","text":"rasterpath character(1). Path raster file. win Named integer vector (4) terra::ext() results.","code":""},{"path":"/reference/rast_short.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Quick call for SpatRaster with a window — rast_short","text":"SpatRaster object.","code":""},{"path":"/reference/rast_short.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Quick call for SpatRaster with a window — rast_short","text":"Insang Song","code":""},{"path":"/reference/reproject_b2r.html","id":null,"dir":"Reference","previous_headings":"","what":"Reproject vectors to raster's CRS — reproject_b2r","title":"Reproject vectors to raster's CRS — reproject_b2r","text":"Reproject vectors raster's CRS","code":""},{"path":"/reference/reproject_b2r.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Reproject vectors to raster's CRS — reproject_b2r","text":"","code":"reproject_b2r(vector, raster)"},{"path":"/reference/reproject_b2r.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Reproject vectors to raster's CRS — reproject_b2r","text":"vector sf/stars/SpatVector/SpatRaster object raster SpatRaster object","code":""},{"path":"/reference/reproject_b2r.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Reproject vectors to raster's CRS — reproject_b2r","text":"Reprojected object class vector","code":""},{"path":"/reference/reproject_b2r.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Reproject vectors to raster's CRS — reproject_b2r","text":"Insang Song","code":""},{"path":"/reference/scomps-package.html","id":null,"dir":"Reference","previous_headings":"","what":"scomps: Scalable R geospatial computation — scomps-package","title":"scomps: Scalable R geospatial computation — scomps-package","text":"package scalable geospatial computation environmental health research","code":""},{"path":"/reference/scomps-package.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"scomps: Scalable R geospatial computation — scomps-package","text":"Maintainer: Insang Song geoissong@gmail.com (ORCID)","code":""},{"path":"/reference/set_clip_extent.html","id":null,"dir":"Reference","previous_headings":"","what":"Setting the clipping extent — set_clip_extent","title":"Setting the clipping extent — set_clip_extent","text":"Return clipping extent buffer radius. assumes input CRS projected linear unit meters.","code":""},{"path":"/reference/set_clip_extent.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Setting the clipping extent — set_clip_extent","text":"","code":"set_clip_extent(pnts, buffer_r)"},{"path":"/reference/set_clip_extent.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Setting the clipping extent — set_clip_extent","text":"pnts One sf vect class. Target points computation. buffer_r numeric(1). Buffer radius. assumed metres","code":""},{"path":"/reference/set_clip_extent.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Setting the clipping extent — set_clip_extent","text":"terra::ext sfc_POLYGON object computation extent.","code":""},{"path":"/reference/set_clip_extent.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Setting the clipping extent — set_clip_extent","text":"Insang Song","code":""},{"path":"/reference/sp_index_grid.html","id":null,"dir":"Reference","previous_headings":"","what":"sp_index_grid: Generate grid polygons — sp_index_grid","title":"sp_index_grid: Generate grid polygons — sp_index_grid","text":"Returns sf object includes x- y- index using two inputs ncutsx ncutsy, x- y-directional splits, respectively.","code":""},{"path":"/reference/sp_index_grid.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"sp_index_grid: Generate grid polygons — sp_index_grid","text":"","code":"sp_index_grid(points_in, ncutsx, ncutsy)"},{"path":"/reference/sp_index_grid.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"sp_index_grid: Generate grid polygons — sp_index_grid","text":"points_in sf SpatVector object. Target points computation. ncutsx integer(1). number splits along x-axis. ncutsy integer(1). number splits along y-axis.","code":""},{"path":"/reference/sp_index_grid.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"sp_index_grid: Generate grid polygons — sp_index_grid","text":"sf SpatVector object computation grids unique grid id (CGRIDID).","code":""},{"path":"/reference/sp_index_grid.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"sp_index_grid: Generate grid polygons — sp_index_grid","text":"Insang Song","code":""},{"path":"/reference/switch_packbound.html","id":null,"dir":"Reference","previous_headings":"","what":"Switch spatial data class — switch_packbound","title":"Switch spatial data class — switch_packbound","text":"Convert stars SpatRaster vice versa; sf SpatVector vice versa.","code":""},{"path":"/reference/switch_packbound.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Switch spatial data class — switch_packbound","text":"","code":"switch_packbound(input)"},{"path":"/reference/switch_packbound.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Switch spatial data class — switch_packbound","text":"input Spat* terra sf object.","code":""},{"path":"/reference/switch_packbound.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Switch spatial data class — switch_packbound","text":"Data converted package class (sf, terra; terra, sf)","code":""},{"path":"/reference/switch_packbound.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Switch spatial data class — switch_packbound","text":"Insang Song","code":""},{"path":"/reference/validate_and_repair_vectors.html","id":null,"dir":"Reference","previous_headings":"","what":"Validate and repair input vector data — validate_and_repair_vectors","title":"Validate and repair input vector data — validate_and_repair_vectors","text":"tries repairing input vector data. Vector validity violation usually appears polygon data self-crossing hole orders. function pass input_vector object sf::st_make_valid() (input_vector sf) terra::makeValid() (input_vector SpatVector). May take time depending geometry complexity.","code":""},{"path":"/reference/validate_and_repair_vectors.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Validate and repair input vector data — validate_and_repair_vectors","text":"","code":"validate_and_repair_vectors(input_vector)"},{"path":"/reference/validate_and_repair_vectors.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Validate and repair input vector data — validate_and_repair_vectors","text":"input_vector One sf vect class. Target points computation.","code":""},{"path":"/reference/validate_and_repair_vectors.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Validate and repair input vector data — validate_and_repair_vectors","text":"repaired sf SpatVector object depending class input_vector.","code":""},{"path":"/reference/validate_and_repair_vectors.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Validate and repair input vector data — validate_and_repair_vectors","text":"Insang Song","code":""}]
