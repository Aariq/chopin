[{"path":[]},{"path":"/CODE_OF_CONDUCT.html","id":"our-pledge","dir":"","previous_headings":"","what":"Our Pledge","title":"Contributor Covenant Code of Conduct","text":"members, contributors, leaders pledge make participation community harassment-free experience everyone, regardless age, body size, visible invisible disability, ethnicity, sex characteristics, gender identity expression, level experience, education, socio-economic status, nationality, personal appearance, race, caste, color, religion, sexual identity orientation. pledge act interact ways contribute open, welcoming, diverse, inclusive, healthy community.","code":""},{"path":"/CODE_OF_CONDUCT.html","id":"our-standards","dir":"","previous_headings":"","what":"Our Standards","title":"Contributor Covenant Code of Conduct","text":"Examples behavior contributes positive environment community include: Demonstrating empathy kindness toward people respectful differing opinions, viewpoints, experiences Giving gracefully accepting constructive feedback Accepting responsibility apologizing affected mistakes, learning experience Focusing best just us individuals, overall community Examples unacceptable behavior include: use sexualized language imagery, sexual attention advances kind Trolling, insulting derogatory comments, personal political attacks Public private harassment Publishing others’ private information, physical email address, without explicit permission conduct reasonably considered inappropriate professional setting","code":""},{"path":"/CODE_OF_CONDUCT.html","id":"enforcement-responsibilities","dir":"","previous_headings":"","what":"Enforcement Responsibilities","title":"Contributor Covenant Code of Conduct","text":"Community leaders responsible clarifying enforcing standards acceptable behavior take appropriate fair corrective action response behavior deem inappropriate, threatening, offensive, harmful. Community leaders right responsibility remove, edit, reject comments, commits, code, wiki edits, issues, contributions aligned Code Conduct, communicate reasons moderation decisions appropriate.","code":""},{"path":"/CODE_OF_CONDUCT.html","id":"scope","dir":"","previous_headings":"","what":"Scope","title":"Contributor Covenant Code of Conduct","text":"Code Conduct applies within community spaces, also applies individual officially representing community public spaces. Examples representing community include using official e-mail address, posting via official social media account, acting appointed representative online offline event.","code":""},{"path":"/CODE_OF_CONDUCT.html","id":"enforcement","dir":"","previous_headings":"","what":"Enforcement","title":"Contributor Covenant Code of Conduct","text":"Instances abusive, harassing, otherwise unacceptable behavior may reported community leaders responsible enforcement geoissong@gmail.com. complaints reviewed investigated promptly fairly. community leaders obligated respect privacy security reporter incident.","code":""},{"path":"/CODE_OF_CONDUCT.html","id":"enforcement-guidelines","dir":"","previous_headings":"","what":"Enforcement Guidelines","title":"Contributor Covenant Code of Conduct","text":"Community leaders follow Community Impact Guidelines determining consequences action deem violation Code Conduct:","code":""},{"path":"/CODE_OF_CONDUCT.html","id":"id_1-correction","dir":"","previous_headings":"Enforcement Guidelines","what":"1. Correction","title":"Contributor Covenant Code of Conduct","text":"Community Impact: Use inappropriate language behavior deemed unprofessional unwelcome community. Consequence: private, written warning community leaders, providing clarity around nature violation explanation behavior inappropriate. public apology may requested.","code":""},{"path":"/CODE_OF_CONDUCT.html","id":"id_2-warning","dir":"","previous_headings":"Enforcement Guidelines","what":"2. Warning","title":"Contributor Covenant Code of Conduct","text":"Community Impact: violation single incident series actions. Consequence: warning consequences continued behavior. interaction people involved, including unsolicited interaction enforcing Code Conduct, specified period time. includes avoiding interactions community spaces well external channels like social media. Violating terms may lead temporary permanent ban.","code":""},{"path":"/CODE_OF_CONDUCT.html","id":"id_3-temporary-ban","dir":"","previous_headings":"Enforcement Guidelines","what":"3. Temporary Ban","title":"Contributor Covenant Code of Conduct","text":"Community Impact: serious violation community standards, including sustained inappropriate behavior. Consequence: temporary ban sort interaction public communication community specified period time. public private interaction people involved, including unsolicited interaction enforcing Code Conduct, allowed period. Violating terms may lead permanent ban.","code":""},{"path":"/CODE_OF_CONDUCT.html","id":"id_4-permanent-ban","dir":"","previous_headings":"Enforcement Guidelines","what":"4. Permanent Ban","title":"Contributor Covenant Code of Conduct","text":"Community Impact: Demonstrating pattern violation community standards, including sustained inappropriate behavior, harassment individual, aggression toward disparagement classes individuals. Consequence: permanent ban sort public interaction within community.","code":""},{"path":"/CODE_OF_CONDUCT.html","id":"attribution","dir":"","previous_headings":"","what":"Attribution","title":"Contributor Covenant Code of Conduct","text":"Code Conduct adapted Contributor Covenant, version 2.1, available https://www.contributor-covenant.org/version/2/1/code_of_conduct.html. Community Impact Guidelines inspired [Mozilla’s code conduct enforcement ladder][https://github.com/mozilla/inclusion]. answers common questions code conduct, see FAQ https://www.contributor-covenant.org/faq. Translations available https://www.contributor-covenant.org/translations.","code":""},{"path":"/LICENSE.html","id":null,"dir":"","previous_headings":"","what":"MIT License","title":"MIT License","text":"Copyright (c) 2024 chopin authors Permission hereby granted, free charge, person obtaining copy software associated documentation files (“Software”), deal Software without restriction, including without limitation rights use, copy, modify, merge, publish, distribute, sublicense, /sell copies Software, permit persons Software furnished , subject following conditions: copyright notice permission notice shall included copies substantial portions Software. SOFTWARE PROVIDED “”, WITHOUT WARRANTY KIND, EXPRESS IMPLIED, INCLUDING LIMITED WARRANTIES MERCHANTABILITY, FITNESS PARTICULAR PURPOSE NONINFRINGEMENT. EVENT SHALL AUTHORS COPYRIGHT HOLDERS LIABLE CLAIM, DAMAGES LIABILITY, WHETHER ACTION CONTRACT, TORT OTHERWISE, ARISING , CONNECTION SOFTWARE USE DEALINGS SOFTWARE.","code":""},{"path":"/articles/v00_good_practice_parallelization.html","id":"assumptions","dir":"Articles","previous_headings":"","what":"Assumptions","title":"Good practice of scomps with HPC","text":"Users accessible HPC work Data stored distributed file systems (usually incorporated HPC system)","code":""},{"path":[]},{"path":"/articles/v00_good_practice_parallelization.html","id":"practice-for-minimizing-errors","dir":"Articles","previous_headings":"Basic workflow","what":"Practice for minimizing errors","title":"Good practice of scomps with HPC","text":"Especially higher-level functions","code":""},{"path":"/articles/v00_good_practice_parallelization.html","id":"raster-vector-overlay","dir":"Articles","previous_headings":"Basic workflow","what":"Raster-Vector overlay","title":"Good practice of scomps with HPC","text":"Make sp_index_grid() get padded grid objects example: c(xmin=0, ymin=0, xmax=10, ymax=10) extent vector element Preprocessed vector objects respect extent vector first list Preferably lists named Write future.apply script running extent list object Run small amount data estimate total computational demand Submit job proper amount computational assets","code":""},{"path":"/articles/v01_par_make_gridset.html","id":"prepare-input-data","dir":"Articles","previous_headings":"","what":"Prepare input data","title":"Generate computational grids","text":"","code":"library(chopin) library(dplyr) library(sf) library(terra) options(sf_use_s2 = FALSE) ncpoly <- system.file(\"shape/nc.shp\", package = \"sf\") ncsf <- sf::read_sf(ncpoly) ncsf <- sf::st_transform(ncsf, \"EPSG:5070\") plot(sf::st_geometry(ncsf)) ncpoints <- sf::st_sample(ncsf, 10000) plot(sf::st_geometry(ncpoints)) # st_sample output is st_sfc. We should convert it to sf ncpoints <- st_as_sf(ncpoints) ncpoints$pid <- seq(1, nrow(ncpoints))"},{"path":[]},{"path":"/articles/v01_par_make_gridset.html","id":"visualize-computational-grids","dir":"Articles","previous_headings":"Computational grids","what":"Visualize computational grids","title":"Generate computational grids","text":"","code":"ncpoints_tr <- terra::vect(ncpoints) compregions <-     chopin::par_make_gridset(         ncpoints_tr,         mode = \"grid\",         nx = 8L,         ny = 5L,         padding = 1e4L     )  names(compregions) ## [1] \"original\" \"padded\" par(mfcol = c(1, 2)) plot(compregions$original, main = \"Original grids\") plot(compregions$padded, main = \"Padded grids\")"},{"path":"/articles/v01_par_make_gridset.html","id":"notes","dir":"Articles","previous_headings":"Computational grids","what":"Notes","title":"Generate computational grids","text":"Computational grids exhaustive split entire study region. take square buffer grid clip target raster vector.","code":""},{"path":"/articles/v02_par_function_example.html","id":"par_-functions-for-automatic-parallelization-for-geospatial-operations","dir":"Articles","previous_headings":"","what":"par_* functions for automatic parallelization for geospatial operations","title":"How to use par_* functions","text":"Please refer small example extracting mean altitude values circular point buffers census tracts North Carolina.","code":"library(chopin) library(dplyr) library(sf) library(terra) library(future) library(future.apply) library(doFuture) library(tigris) options(sf_use_s2 = FALSE) set.seed(2023, kind = \"L'Ecuyer-CMRG\") ncpoly <- system.file(\"shape/nc.shp\", package = \"sf\") ncsf <- sf::read_sf(ncpoly) ncsf <- sf::st_transform(ncsf, \"EPSG:5070\") plot(sf::st_geometry(ncsf))"},{"path":"/articles/v02_par_function_example.html","id":"generate-random-points-in-nc","dir":"Articles","previous_headings":"par_* functions for automatic parallelization for geospatial operations","what":"Generate random points in NC","title":"How to use par_* functions","text":"Ten thousands random point locations generated inside counties North Carolina.","code":"ncpoints <- sf::st_sample(ncsf, 10000) plot(sf::st_geometry(ncpoints)) # st_sample output is st_sfc. We should convert it to sf ncpoints <- st_as_sf(ncpoints) ncpoints$pid <- seq(1, nrow(ncpoints))"},{"path":"/articles/v02_par_function_example.html","id":"target-dataset-shuttle-radar-topography-mission","dir":"Articles","previous_headings":"par_* functions for automatic parallelization for geospatial operations","what":"Target dataset: Shuttle Radar Topography Mission","title":"How to use par_* functions","text":"use elevation dataset moderate spatial resolution (approximately 400 meters 0.25 miles).","code":"srtm <- terra::unwrap(readRDS(\"../../tests/testdata/nc_srtm15_otm.rds\")) srtm #> class       : SpatRaster  #> dimensions  : 1534, 2281, 1  (nrow, ncol, nlyr) #> resolution  : 391.5026, 391.5026  (x, y) #> extent      : 1012872, 1905890, 1219961, 1820526  (xmin, xmax, ymin, ymax) #> coord. ref. : +proj=aea +lat_0=23 +lon_0=-96 +lat_1=29.5 +lat_2=45.5 +x_0=0 +y_0=0 +datum=NAD83 +units=m +no_defs  #> source(s)   : memory #> name        : file928c3830468b  #> min value   :        -3589.291  #> max value   :         1946.400 plot(srtm) terra::crs(srtm) <- \"EPSG:5070\" ncpoints_tr <- terra::vect(ncpoints) system.time(   ncpoints_srtm <-     chopin::extract_at(       vector = ncpoints_tr,       raster = srtm,       id = \"pid\",       mode = \"buffer\",       radius = 1e4L) # 10,000 meters (10 km) ) #>    user  system elapsed  #>   6.271   0.210   6.484"},{"path":"/articles/v02_par_function_example.html","id":"generate-regular-grid-computational-regions","dir":"Articles","previous_headings":"par_* functions for automatic parallelization for geospatial operations","what":"Generate regular grid computational regions","title":"How to use par_* functions","text":"chopin::par_make_gridset takes locations generate regular grid polygons nx ny arguments padding. Users overlapping (degree radius) non-overlapping grids, utilized split locations target datasets sub-datasets efficient processing. compregions object two elements named original (non-overlapping grid polygons) padded (overlapping padding). figures illustrate grid polygons without overlaps.","code":"compregions <-   chopin::par_make_gridset(     ncpoints_tr,     mode = \"grid\",     nx = 8L,     ny = 5L,     padding = 1e4L   ) names(compregions) #> [1] \"original\" \"padded\"  oldpar <- par() par(mfcol = c(1, 2)) plot(compregions$original, main = \"Original grids\") plot(compregions$padded, main = \"Padded grids\") par(oldpar)"},{"path":"/articles/v02_par_function_example.html","id":"parallel-processing","dir":"Articles","previous_headings":"par_* functions for automatic parallelization for geospatial operations","what":"Parallel processing","title":"How to use par_* functions","text":"Using grid polygons, distribute task averaging elevations 10,000 circular buffer polygons, generated random locations, 10 kilometers radius chopin::par_grid Users always need register multiple CPU threads (logical cores) enable used R processes. Users can inject generic functions’ arguments (parameters) writing ellipsis arguments, like : ``` r plan(multicore, workers = 4L) doFuture::registerDoFuture() system.time( ncpoints_srtm_mthr <- chopin::distribute_process_grid( grids = compregions, grid_target_id = NULL, fun_dist = chopin::extract_at, vector = ncpoints_tr, raster = srtm, id = “pid”, mode = “buffer”, radius = 1e4L ) ) #> input function #> successfully run CGRIDID: 1 #> input function #> successfully run CGRIDID: 2 #> input function #> successfully run CGRIDID: 3 #> input function #> successfully run CGRIDID: 4 #> input function #> successfully run CGRIDID: 5 #> input function #> successfully run CGRIDID: 6 #> input function #> successfully run CGRIDID: 7 #> input function #> successfully run CGRIDID: 8 #> input function #> successfully run CGRIDID: 9 #> input function #> successfully run CGRIDID: 10 #> input function #> successfully run CGRIDID: 11 #> input function #> successfully run CGRIDID: 12 #> input function #> successfully run CGRIDID: 13 #> input function #> successfully run CGRIDID: 14 #> input function #> successfully run CGRIDID: 15 #> input function #> successfully run CGRIDID: 16 #> input function #> successfully run CGRIDID: 17 #> input function #> successfully run CGRIDID: 18 #> input function #> successfully run CGRIDID: 19 #> input function #> successfully run CGRIDID: 20 #> input function #> successfully run CGRIDID: 21 #> input function #> successfully run CGRIDID: 22 #> input function #> successfully run CGRIDID: 23 #> input function #> successfully run CGRIDID: 24 #> input function #> successfully run CGRIDID: 25 #> input function #> successfully run CGRIDID: 26 #> input function #> successfully run CGRIDID: 27 #> input function #> successfully run CGRIDID: 28 #> input function #> successfully run CGRIDID: 29 #> input function #> successfully run CGRIDID: 30 #> input function #> successfully run CGRIDID: 31 #> input function #> successfully run CGRIDID: 32 #> input function #> successfully run CGRIDID: 33 #> user system elapsed #> 4.407 0.351 2.438","code":"``` r ncpoints_srtm_mthr <-   ncpoints_srtm_mthr[order(ncpoints_srtm_mthr$pid),] all.equal(ncpoints_srtm, ncpoints_srtm_mthr) #> [1] \"Attributes: < Component \\\"row.names\\\": Mean relative difference: 0.6567904 >\" #> [2] \"Component \\\"mean\\\": Mean relative difference: 8.712634e-05\" ncpoints_s <-     merge(ncpoints, ncpoints_srtm) ncpoints_m <-     merge(ncpoints, ncpoints_srtm_mthr)  plot(ncpoints_s[, \"mean\"], main = \"Single-thread\") plot(ncpoints_m[, \"mean\"], main = \"Multi-thread\")"},{"path":"/articles/v02_par_function_example.html","id":"parallelize-geospatial-computations-using-intrinsic-data-hierarchy-chopinpar_hierarchy","dir":"Articles","previous_headings":"par_* functions for automatic parallelization for geospatial operations","what":"Parallelize geospatial computations using intrinsic data hierarchy: chopin::par_hierarchy","title":"How to use par_* functions","text":"real world datasets, usually nested/exhaustive hierarchies. example, land organized administrative/jurisdictional borders multiple levels exist. U.S. context, state consists several counties, counties split census tracts, group block groups. chopin::par_hierarchy leverages hierarchies parallelize geospatial operations, means group lower-level geographic units higher-level geography assigned process. demonstration shows census tracts grouped counties county processed CPU thread.","code":"nc_county <- file.path(\"../testdata/nc_hierarchy.gpkg\") nc_county <- sf::st_read(nc_county, layer = \"county\") #> Reading layer `county' from data source  #>   `/Users/songi2/Documents/GitHub/Scalable_GIS/tools/testdata/nc_hierarchy.gpkg'  #>   using driver `GPKG' #> Simple feature collection with 100 features and 1 field #> Geometry type: POLYGON #> Dimension:     XY #> Bounding box:  xmin: 1054155 ymin: 1341756 xmax: 1838923 ymax: 1690176 #> Projected CRS: NAD83 / Conus Albers  nc_tracts <- file.path(\"../testdata/nc_hierarchy.gpkg\") nc_tracts <- sf::st_read(nc_tracts, layer = \"tracts\") #> Reading layer `tracts' from data source  #>   `/Users/songi2/Documents/GitHub/Scalable_GIS/tools/testdata/nc_hierarchy.gpkg'  #>   using driver `GPKG' #> Simple feature collection with 2672 features and 1 field #> Geometry type: MULTIPOLYGON #> Dimension:     XY #> Bounding box:  xmin: 1054155 ymin: 1341756 xmax: 1838923 ymax: 1690176 #> Projected CRS: NAD83 / Conus Albers  nc_county <- sf::st_transform(nc_county, \"EPSG:5070\") nc_tracts <- sf::st_transform(nc_tracts, \"EPSG:5070\") nc_tracts$COUNTY <-   substr(nc_tracts$GEOID, 1, 5) system.time(   nc_elev_tr_single <- chopin::extract_at(     vector = nc_tracts,     raster = srtm,     id = \"GEOID\",     mode = \"polygon\"   ) ) #>    user  system elapsed  #>   1.082   0.021   1.102 system.time(   nc_elev_tr_distr <-     chopin::par_hierarchy(       regions = nc_county, # higher level geometry       split_level = \"GEOID\", # higher level unique id       fun_dist = chopin::extract_at,       vector = nc_tracts, # lower level geometry       raster = srtm,       id = \"GEOID\", # lower level unique id       func = \"mean\"     ) ) #>    user  system elapsed  #>   0.023   0.013   1.317"},{"path":"/articles/v02_par_function_example.html","id":"multiple-rasters","dir":"Articles","previous_headings":"par_* functions for automatic parallelization for geospatial operations","what":"Multiple rasters","title":"How to use par_* functions","text":"common case large group raster files operation performed. chopin::distribute_process_multirasters cases. example demonstrates five elevation raster files calculate average elevation counties North Carolina.","code":"ncpath <- \"../testdata/nc_hierarchy.gpkg\" nccnty <- terra::vect(ncpath, layer = \"county\") ncelev <- terra::unwrap(readRDS(\"../testdata/nc_srtm15_otm.rds\")) terra::crs(ncelev) <- \"EPSG:5070\" names(ncelev) <- c(\"srtm15\") tdir <- tempdir() terra::writeRaster(ncelev, file.path(tdir, \"test1.tif\"), overwrite = TRUE) terra::writeRaster(ncelev, file.path(tdir, \"test2.tif\"), overwrite = TRUE) terra::writeRaster(ncelev, file.path(tdir, \"test3.tif\"), overwrite = TRUE) terra::writeRaster(ncelev, file.path(tdir, \"test4.tif\"), overwrite = TRUE) terra::writeRaster(ncelev, file.path(tdir, \"test5.tif\"), overwrite = TRUE)  testfiles <- list.files(tempdir(), pattern = \"*.tif$\", full.names = TRUE) testfiles #> [1] \"/var/folders/58/7rn_bn5d6k3_cxwnzdhswpz4n0z2n9/T//RtmpUJwWlN/test1.tif\" #> [2] \"/var/folders/58/7rn_bn5d6k3_cxwnzdhswpz4n0z2n9/T//RtmpUJwWlN/test2.tif\" #> [3] \"/var/folders/58/7rn_bn5d6k3_cxwnzdhswpz4n0z2n9/T//RtmpUJwWlN/test3.tif\" #> [4] \"/var/folders/58/7rn_bn5d6k3_cxwnzdhswpz4n0z2n9/T//RtmpUJwWlN/test4.tif\" #> [5] \"/var/folders/58/7rn_bn5d6k3_cxwnzdhswpz4n0z2n9/T//RtmpUJwWlN/test5.tif\" res <- par_multirasters(       filenames = testfiles,       fun_dist = extract_at_poly,       polys = nccnty,       surf = ncelev,       id = \"GEOID\",       func = \"mean\"     )  knitr::kable(head(res))"},{"path":"/articles/v02_par_function_example.html","id":"parallelization-of-a-generic-geospatial-operation","dir":"Articles","previous_headings":"par_* functions for automatic parallelization for geospatial operations","what":"Parallelization of a generic geospatial operation","title":"How to use par_* functions","text":"chopin internal macros, chopin::distribute_process_* functions support generic geospatial operations. example uses terra::nearest, gets nearest feature’s attributes, inside chopin::distribute_process_grid.","code":"pnts <- readRDS(\"../testdata/nc_random_point.rds\") pnts <- terra::vect(pnts) rd1 <- terra::vect(     file.path(\"../testdata/ncroads_first.gpkg\"))  pnts <- terra::project(pnts, \"EPSG:5070\") rd1 <- terra::project(rd1, \"EPSG:5070\")   nccompreg <-   par_make_gridset(     input = pnts,     mode = \"grid\",     nx = 6L,     ny = 4L,     padding = 3e4L   )    future::plan(future::multicore, workers = 6L)  system.time( res <-   distribute_process_grid(     grids = nccompreg,     fun_dist = terra::nearest,     x = pnts,     y = rd1   ) ) #> Your input function was  #>             successfully run at CGRIDID: 1 #> Your input function was  #>             successfully run at CGRIDID: 2 #> Your input function was  #>             successfully run at CGRIDID: 3 #> Your input function was  #>             successfully run at CGRIDID: 4 #> Your input function was  #>             successfully run at CGRIDID: 5 #> Your input function was  #>             successfully run at CGRIDID: 6 #> Your input function was  #>             successfully run at CGRIDID: 7 #> Your input function was  #>             successfully run at CGRIDID: 8 #> Your input function was  #>             successfully run at CGRIDID: 9 #> Your input function was  #>             successfully run at CGRIDID: 10 #> Your input function was  #>             successfully run at CGRIDID: 11 #> Your input function was  #>             successfully run at CGRIDID: 12 #> Your input function was  #>             successfully run at CGRIDID: 13 #> Your input function was  #>             successfully run at CGRIDID: 14 #> Your input function was  #>             successfully run at CGRIDID: 15 #> Your input function was  #>             successfully run at CGRIDID: 16 #> Your input function was  #>             successfully run at CGRIDID: 17 #> Your input function was  #>             successfully run at CGRIDID: 18 #> Your input function was  #>             successfully run at CGRIDID: 19 #> Your input function was  #>             successfully run at CGRIDID: 20 #>    user  system elapsed  #>   0.366   0.265   0.173    system.time(   restr <- terra::nearest(x = pnts, y = rd1) ) #>    user  system elapsed  #>   0.036   0.000   0.036"},{"path":"/articles/v02_par_function_example.html","id":"why-parallelization-is-slower-than-the-ordinary-function-run","dir":"Articles","previous_headings":"par_* functions for automatic parallelization for geospatial operations","what":"Why parallelization is slower than the ordinary function run?","title":"How to use par_* functions","text":"Parallelization may underperform datasets small take advantage divide--compute approach, parallelization overhead involved. Overhead refers required amount computational resources transferring objects multiple processes. Since demonstrations use quite small datasets, advantage parallelization dramatically expected. large amount data (spatial/temporal resolution number files, example) processed, users see efficiency package. illustrative truly scaled examples added vignette soon.","code":""},{"path":"/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Insang Song. Author, maintainer. Kyle Messier. Author, contributor.","code":""},{"path":"/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Song , Messier K (2024). chopin: CHOPIN: Computation Climate Health research Parallelized INfrastructure. R package version 0.3.0.20240131, https://github.com/Spatiotemporal-Exposures--Toxicology/Scalable_GIS.","code":"@Manual{,   title = {chopin: CHOPIN: Computation for Climate and Health research On Parallelized INfrastructure},   author = {Insang Song and Kyle Messier},   year = {2024},   note = {R package version 0.3.0.20240131},   url = {https://github.com/Spatiotemporal-Exposures-and-Toxicology/Scalable_GIS}, }"},{"path":[]},{"path":"/index.html","id":"basic-design","dir":"","previous_headings":"","what":"Basic design","title":"CHOPIN: Computation for Climate and Health research On Parallelized INfrastructure","text":"Processing functions accept sf/terra classes spatial data. Raster-vector overlay done exactextractr. extract_at_poly extract_at_buffer summarize_sedc: calculate sums exponentially decaying contributions summarize_aw: area-weighted covariates based target reference polygons par_grid par_hierarchy par_multirasters","code":""},{"path":"/index.html","id":"installation","dir":"","previous_headings":"","what":"Installation","title":"CHOPIN: Computation for Climate and Health research On Parallelized INfrastructure","text":"can install chopin using pak::pak remotes::install_github","code":"pak::pak(\"Spatiotemporal-Exposures-and-Toxicology/Scalable-GIS\") remotes::install_github(\"Spatiotemporal-Exposures-and-Toxicology/Scalable-GIS\")"},{"path":"/index.html","id":"use-case","dir":"","previous_headings":"","what":"Use case","title":"CHOPIN: Computation for Climate and Health research On Parallelized INfrastructure","text":"Please refer small example extracting mean altitude values circular point buffers census tracts North Carolina.","code":"library(chopin) library(dplyr) library(sf) library(terra) library(future) library(future.apply) library(doFuture) library(tigris) options(sf_use_s2 = FALSE) set.seed(2023, kind = \"L'Ecuyer-CMRG\") ncpoly <- system.file(\"shape/nc.shp\", package = \"sf\") ncsf <- sf::read_sf(ncpoly) ncsf <- sf::st_transform(ncsf, \"EPSG:5070\") plot(sf::st_geometry(ncsf))"},{"path":"/index.html","id":"generate-random-points-in-nc","dir":"","previous_headings":"Use case","what":"Generate random points in NC","title":"CHOPIN: Computation for Climate and Health research On Parallelized INfrastructure","text":"Ten thousands random point locations generated inside counties North Carolina.","code":"ncpoints <- sf::st_sample(ncsf, 10000) plot(sf::st_geometry(ncpoints)) # st_sample output is st_sfc. We should convert it to sf ncpoints <- st_as_sf(ncpoints) ncpoints$pid <- seq(1, nrow(ncpoints))"},{"path":"/index.html","id":"target-dataset-shuttle-radar-topography-mission","dir":"","previous_headings":"Use case","what":"Target dataset: Shuttle Radar Topography Mission","title":"CHOPIN: Computation for Climate and Health research On Parallelized INfrastructure","text":"use elevation dataset moderate spatial resolution (approximately 400 meters 0.25 miles).","code":"srtm <- terra::unwrap(readRDS(\"../../tests/testdata/nc_srtm15_otm.rds\")) srtm #> class       : SpatRaster  #> dimensions  : 1534, 2281, 1  (nrow, ncol, nlyr) #> resolution  : 391.5026, 391.5026  (x, y) #> extent      : 1012872, 1905890, 1219961, 1820526  (xmin, xmax, ymin, ymax) #> coord. ref. : +proj=aea +lat_0=23 +lon_0=-96 +lat_1=29.5 +lat_2=45.5 +x_0=0 +y_0=0 +datum=NAD83 +units=m +no_defs  #> source(s)   : memory #> name        : file928c3830468b  #> min value   :        -3589.291  #> max value   :         1946.400 plot(srtm) terra::crs(srtm) <- \"EPSG:5070\" ncpoints_tr <- terra::vect(ncpoints) system.time(   ncpoints_srtm <-     chopin::extract_at(       vector = ncpoints_tr,       raster = srtm,       id = \"pid\",       mode = \"buffer\",       radius = 1e4L) # 10,000 meters (10 km) ) #>    user  system elapsed  #>   6.271   0.210   6.484"},{"path":"/index.html","id":"generate-regular-grid-computational-regions","dir":"","previous_headings":"Use case","what":"Generate regular grid computational regions","title":"CHOPIN: Computation for Climate and Health research On Parallelized INfrastructure","text":"chopin::par_make_gridset takes locations generate regular grid polygons nx ny arguments padding. Users overlapping (degree radius) non-overlapping grids, utilized split locations target datasets sub-datasets efficient processing. compregions object two elements named original (non-overlapping grid polygons) padded (overlapping padding). figures illustrate grid polygons without overlaps.","code":"compregions <-   chopin::par_make_gridset(     ncpoints_tr,     mode = \"grid\",     nx = 8L,     ny = 5L,     padding = 1e4L   ) names(compregions) #> [1] \"original\" \"padded\"  oldpar <- par() par(mfcol = c(1, 2)) plot(compregions$original, main = \"Original grids\") plot(compregions$padded, main = \"Padded grids\") par(oldpar)"},{"path":"/index.html","id":"parallel-processing","dir":"","previous_headings":"Use case","what":"Parallel processing","title":"CHOPIN: Computation for Climate and Health research On Parallelized INfrastructure","text":"Using grid polygons, distribute task averaging elevations 10,000 circular buffer polygons, generated random locations, 10 kilometers radius chopin::par_grid Users always need register multiple CPU threads (logical cores) enable used R processes. Users can inject generic functions’ arguments (parameters) writing ellipsis arguments, like : ``` r plan(multicore, workers = 4L) doFuture::registerDoFuture() system.time( ncpoints_srtm_mthr <- chopin::par_grid( grids = compregions, grid_target_id = NULL, fun_dist = chopin::extract_at, vector = ncpoints_tr, raster = srtm, id = “pid”, mode = “buffer”, radius = 1e4L ) ) #> input function #> successfully run CGRIDID: 1 #> input function #> successfully run CGRIDID: 2 #> input function #> successfully run CGRIDID: 3 #> input function #> successfully run CGRIDID: 4 #> input function #> successfully run CGRIDID: 5 #> input function #> successfully run CGRIDID: 6 #> input function #> successfully run CGRIDID: 7 #> input function #> successfully run CGRIDID: 8 #> input function #> successfully run CGRIDID: 9 #> input function #> successfully run CGRIDID: 10 #> input function #> successfully run CGRIDID: 11 #> input function #> successfully run CGRIDID: 12 #> input function #> successfully run CGRIDID: 13 #> input function #> successfully run CGRIDID: 14 #> input function #> successfully run CGRIDID: 15 #> input function #> successfully run CGRIDID: 16 #> input function #> successfully run CGRIDID: 17 #> input function #> successfully run CGRIDID: 18 #> input function #> successfully run CGRIDID: 19 #> input function #> successfully run CGRIDID: 20 #> input function #> successfully run CGRIDID: 21 #> input function #> successfully run CGRIDID: 22 #> input function #> successfully run CGRIDID: 23 #> input function #> successfully run CGRIDID: 24 #> input function #> successfully run CGRIDID: 25 #> input function #> successfully run CGRIDID: 26 #> input function #> successfully run CGRIDID: 27 #> input function #> successfully run CGRIDID: 28 #> input function #> successfully run CGRIDID: 29 #> input function #> successfully run CGRIDID: 30 #> input function #> successfully run CGRIDID: 31 #> input function #> successfully run CGRIDID: 32 #> input function #> successfully run CGRIDID: 33 #> user system elapsed #> 4.407 0.351 2.438","code":"``` r ncpoints_srtm_mthr <-   ncpoints_srtm_mthr[order(ncpoints_srtm_mthr$pid),] all.equal(ncpoints_srtm, ncpoints_srtm_mthr) #> [1] \"Attributes: < Component \\\"row.names\\\": Mean relative difference: 0.6567904 >\" #> [2] \"Component \\\"mean\\\": Mean relative difference: 8.712634e-05\" ncpoints_s <-     merge(ncpoints, ncpoints_srtm) ncpoints_m <-     merge(ncpoints, ncpoints_srtm_mthr)  plot(ncpoints_s[, \"mean\"], main = \"Single-thread\") plot(ncpoints_m[, \"mean\"], main = \"Multi-thread\")"},{"path":"/index.html","id":"parallelize-geospatial-computations-using-intrinsic-data-hierarchy-chopinpar_hierarchy","dir":"","previous_headings":"Use case","what":"Parallelize geospatial computations using intrinsic data hierarchy: chopin::par_hierarchy","title":"CHOPIN: Computation for Climate and Health research On Parallelized INfrastructure","text":"real world datasets, usually nested/exhaustive hierarchies. example, land organized administrative/jurisdictional borders multiple levels exist. U.S. context, state consists several counties, counties split census tracts, group block groups. chopin::par_hierarchy leverages hierarchies parallelize geospatial operations, means group lower-level geographic units higher-level geography assigned process. demonstration shows census tracts grouped counties county processed CPU thread.","code":"nc_county <- file.path(\"../testdata/nc_hierarchy.gpkg\") nc_county <- sf::st_read(nc_county, layer = \"county\") #> Reading layer `county' from data source  #>   `/Users/songi2/Documents/GitHub/Scalable_GIS/tools/testdata/nc_hierarchy.gpkg'  #>   using driver `GPKG' #> Simple feature collection with 100 features and 1 field #> Geometry type: POLYGON #> Dimension:     XY #> Bounding box:  xmin: 1054155 ymin: 1341756 xmax: 1838923 ymax: 1690176 #> Projected CRS: NAD83 / Conus Albers  nc_tracts <- file.path(\"../testdata/nc_hierarchy.gpkg\") nc_tracts <- sf::st_read(nc_tracts, layer = \"tracts\") #> Reading layer `tracts' from data source  #>   `/Users/songi2/Documents/GitHub/Scalable_GIS/tools/testdata/nc_hierarchy.gpkg'  #>   using driver `GPKG' #> Simple feature collection with 2672 features and 1 field #> Geometry type: MULTIPOLYGON #> Dimension:     XY #> Bounding box:  xmin: 1054155 ymin: 1341756 xmax: 1838923 ymax: 1690176 #> Projected CRS: NAD83 / Conus Albers  nc_county <- sf::st_transform(nc_county, \"EPSG:5070\") nc_tracts <- sf::st_transform(nc_tracts, \"EPSG:5070\") nc_tracts$COUNTY <-   substr(nc_tracts$GEOID, 1, 5) system.time(   nc_elev_tr_single <- chopin::extract_at(     vector = nc_tracts,     raster = srtm,     id = \"GEOID\",     mode = \"polygon\"   ) ) #>    user  system elapsed  #>   1.082   0.021   1.102 system.time(   nc_elev_tr_distr <-     chopin::par_hierarchy(       regions = nc_county, # higher level geometry       split_level = \"GEOID\", # higher level unique id       fun_dist = chopin::extract_at,       vector = nc_tracts, # lower level geometry       raster = srtm,       id = \"GEOID\", # lower level unique id       func = \"mean\"     ) ) #>    user  system elapsed  #>   0.023   0.013   1.317"},{"path":"/index.html","id":"multiple-rasters","dir":"","previous_headings":"Use case","what":"Multiple rasters","title":"CHOPIN: Computation for Climate and Health research On Parallelized INfrastructure","text":"common case large group raster files operation performed. chopin::par_multirasters cases. example demonstrates five elevation raster files calculate average elevation counties North Carolina.","code":"ncpath <- \"../testdata/nc_hierarchy.gpkg\" nccnty <- terra::vect(ncpath, layer = \"county\") ncelev <- terra::unwrap(readRDS(\"../testdata/nc_srtm15_otm.rds\")) terra::crs(ncelev) <- \"EPSG:5070\" names(ncelev) <- c(\"srtm15\") tdir <- tempdir() terra::writeRaster(ncelev, file.path(tdir, \"test1.tif\"), overwrite = TRUE) terra::writeRaster(ncelev, file.path(tdir, \"test2.tif\"), overwrite = TRUE) terra::writeRaster(ncelev, file.path(tdir, \"test3.tif\"), overwrite = TRUE) terra::writeRaster(ncelev, file.path(tdir, \"test4.tif\"), overwrite = TRUE) terra::writeRaster(ncelev, file.path(tdir, \"test5.tif\"), overwrite = TRUE)  testfiles <- list.files(tempdir(), pattern = \"*.tif$\", full.names = TRUE) testfiles #> [1] \"/var/folders/58/7rn_bn5d6k3_cxwnzdhswpz4n0z2n9/T//RtmpUJwWlN/test1.tif\" #> [2] \"/var/folders/58/7rn_bn5d6k3_cxwnzdhswpz4n0z2n9/T//RtmpUJwWlN/test2.tif\" #> [3] \"/var/folders/58/7rn_bn5d6k3_cxwnzdhswpz4n0z2n9/T//RtmpUJwWlN/test3.tif\" #> [4] \"/var/folders/58/7rn_bn5d6k3_cxwnzdhswpz4n0z2n9/T//RtmpUJwWlN/test4.tif\" #> [5] \"/var/folders/58/7rn_bn5d6k3_cxwnzdhswpz4n0z2n9/T//RtmpUJwWlN/test5.tif\" res <- par_multirasters(       filenames = testfiles,       fun_dist = extract_at_poly,       polys = nccnty,       surf = ncelev,       id = \"GEOID\",       func = \"mean\"     )  knitr::kable(head(res))"},{"path":"/index.html","id":"parallelization-of-a-generic-geospatial-operation","dir":"","previous_headings":"Use case","what":"Parallelization of a generic geospatial operation","title":"CHOPIN: Computation for Climate and Health research On Parallelized INfrastructure","text":"chopin internal macros, chopin::par_* functions support parallelize generic geospatial operations two layers involved. example uses terra::nearest, gets nearest feature’s attributes, inside chopin::par_grid.","code":"pnts <- readRDS(\"../testdata/nc_random_point.rds\") pnts <- terra::vect(pnts) rd1 <- terra::vect(     file.path(\"../testdata/ncroads_first.gpkg\"))  pnts <- terra::project(pnts, \"EPSG:5070\") rd1 <- terra::project(rd1, \"EPSG:5070\")   nccompreg <-   par_make_gridset(     input = pnts,     mode = \"grid\",     nx = 6L,     ny = 4L,     padding = 3e4L   )    future::plan(future::multicore, workers = 6L)  system.time( res <-   par_grid(     grids = nccompreg,     fun_dist = terra::nearest,     x = pnts,     y = rd1   ) ) #> Your input function was  #>             successfully run at CGRIDID: 1 #> Your input function was  #>             successfully run at CGRIDID: 2 #> Your input function was  #>             successfully run at CGRIDID: 3 #> Your input function was  #>             successfully run at CGRIDID: 4 #> Your input function was  #>             successfully run at CGRIDID: 5 #> Your input function was  #>             successfully run at CGRIDID: 6 #> Your input function was  #>             successfully run at CGRIDID: 7 #> Your input function was  #>             successfully run at CGRIDID: 8 #> Your input function was  #>             successfully run at CGRIDID: 9 #> Your input function was  #>             successfully run at CGRIDID: 10 #> Your input function was  #>             successfully run at CGRIDID: 11 #> Your input function was  #>             successfully run at CGRIDID: 12 #> Your input function was  #>             successfully run at CGRIDID: 13 #> Your input function was  #>             successfully run at CGRIDID: 14 #> Your input function was  #>             successfully run at CGRIDID: 15 #> Your input function was  #>             successfully run at CGRIDID: 16 #> Your input function was  #>             successfully run at CGRIDID: 17 #> Your input function was  #>             successfully run at CGRIDID: 18 #> Your input function was  #>             successfully run at CGRIDID: 19 #> Your input function was  #>             successfully run at CGRIDID: 20 #>    user  system elapsed  #>   0.366   0.265   0.173    system.time(   restr <- terra::nearest(x = pnts, y = rd1) ) #>    user  system elapsed  #>   0.036   0.000   0.036"},{"path":"/index.html","id":"why-parallelization-is-slower-than-the-ordinary-function-run","dir":"","previous_headings":"Use case","what":"Why parallelization is slower than the ordinary function run?","title":"CHOPIN: Computation for Climate and Health research On Parallelized INfrastructure","text":"Parallelization may underperform datasets small take advantage divide--compute approach, parallelization overhead involved. Overhead refers required amount computational resources transferring objects multiple processes. Since demonstrations use quite small datasets, advantage parallelization dramatically expected. large amount data (spatial/temporal resolution number files, example) processed, users see efficiency package. illustrative truly scaled examples added vignette soon.","code":""},{"path":[]},{"path":"/reference/any_class_args.html","id":null,"dir":"Reference","previous_headings":"","what":"Detect classes in function arguments — any_class_args","title":"Detect classes in function arguments — any_class_args","text":"R function defined ordinary fashion (.e., assigning function <- function(...)) subject ambiguity particularly function name generic function name(s). function supports detecting classes arguments loosely defined function.","code":""},{"path":"/reference/any_class_args.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Detect classes in function arguments — any_class_args","text":"","code":"any_class_args(args = NULL, search = NULL)"},{"path":"/reference/any_class_args.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Detect classes in function arguments — any_class_args","text":"args list, preferably generated list(...) inside function. search character(1). Class name search. Partial match supported.","code":""},{"path":"/reference/any_class_args.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Detect classes in function arguments — any_class_args","text":"logical vector.","code":""},{"path":"/reference/any_class_args.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Detect classes in function arguments — any_class_args","text":"Insang Song","code":""},{"path":"/reference/any_class_args.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Detect classes in function arguments — any_class_args","text":"","code":"df <- data.frame(a = 1, b = 3) any_class_args(list(df), \"data.frame\") #> [1] TRUE"},{"path":"/reference/clip_ras_ext.html","id":null,"dir":"Reference","previous_headings":"","what":"Clip input raster with a buffered vector extent. — clip_ras_ext","title":"Clip input raster with a buffered vector extent. — clip_ras_ext","text":"Clip input raster expected maximum extent computation.","code":""},{"path":"/reference/clip_ras_ext.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Clip input raster with a buffered vector extent. — clip_ras_ext","text":"","code":"clip_ras_ext(pnts = NULL, radius = NULL, ras = NULL, nqsegs = 180L)"},{"path":"/reference/clip_ras_ext.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Clip input raster with a buffered vector extent. — clip_ras_ext","text":"pnts sf SpatVector object radius numeric(1). buffer radius. value automatically multiplied 1.25 ras SpatRaster object clipped nqsegs integer(1). number points per quarter circle","code":""},{"path":"/reference/clip_ras_ext.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Clip input raster with a buffered vector extent. — clip_ras_ext","text":"Insang Song","code":""},{"path":"/reference/clip_ras_ext.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Clip input raster with a buffered vector extent. — clip_ras_ext","text":"","code":"library(terra) #> terra 1.7.65  ras_rand <- terra::rast(nrow = 20, ncol = 20) terra::values(ras_rand) <- runif(400L) ras_rand_p <-   data.frame(     x = c(3, 5, 3.2, 8),     y = c(12, 10, 15, 12),     z = c(0, 1, 2, 3)   ) ras_rand_p <- terra::vect(ras_rand_p, geom = c(\"x\", \"y\")) clip_ras_ext(ras_rand_p, 1.5, ras_rand) #> class       : SpatRaster  #> dimensions  : 2, 1, 1  (nrow, ncol, nlyr) #> resolution  : 18, 9  (x, y) #> extent      : 0, 18, 0, 18  (xmin, xmax, ymin, ymax) #> coord. ref. : lon/lat WGS 84  #> source(s)   : memory #> name        :     lyr.1  #> min value   : 0.8666157  #> max value   : 0.9528248"},{"path":"/reference/clip_vec_ext.html","id":null,"dir":"Reference","previous_headings":"","what":"Clip to the buffered extent of input vector — clip_vec_ext","title":"Clip to the buffered extent of input vector — clip_vec_ext","text":"Clip input vector expected maximum extent computation.","code":""},{"path":"/reference/clip_vec_ext.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Clip to the buffered extent of input vector — clip_vec_ext","text":"","code":"clip_vec_ext(pnts, radius, target_input)"},{"path":"/reference/clip_vec_ext.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Clip to the buffered extent of input vector — clip_vec_ext","text":"pnts sf SpatVector object radius numeric(1). Circular buffer radius. value automatically multiplied 1.1 target_input sf SpatVector object clipped","code":""},{"path":"/reference/clip_vec_ext.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Clip to the buffered extent of input vector — clip_vec_ext","text":"clipped sf SpatVector object.","code":""},{"path":"/reference/clip_vec_ext.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Clip to the buffered extent of input vector — clip_vec_ext","text":"Insang Song","code":""},{"path":"/reference/clip_vec_ext.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Clip to the buffered extent of input vector — clip_vec_ext","text":"","code":"library(sf) #> Linking to GEOS 3.10.2, GDAL 3.4.1, PROJ 8.2.1; sf_use_s2() is TRUE library(stars) #> Loading required package: abind library(terra) options(sf_use_s2 = FALSE)  bcsd_path <- system.file(package = \"stars\", \"nc/bcsd_obs_1999.nc\") bcsd <- stars::read_stars(bcsd_path) #> pr, tas,  bcsd <- sf::st_as_sf(bcsd) bcsd_rpnt <- sf::st_as_sf(sf::st_sample(bcsd, 4L)) bcsd_rpntm <- sf::st_as_sf(sf::st_sample(bcsd, 1000L)) clip_vec_ext(bcsd_rpntm, 1000, bcsd_rpnt) #> Clip target features with the input feature extent... #> Simple feature collection with 4 features and 0 fields #> Geometry type: POINT #> Dimension:     XY #> Bounding box:  xmin: -82.93117 ymin: 33.02974 xmax: -77.41361 ymax: 34.6201 #> CRS:           NA #>                            x #> 1 POINT (-81.62004 34.58888) #> 2  POINT (-77.41361 34.6201) #> 3 POINT (-82.93117 33.02974) #> 4 POINT (-80.22347 34.50031)"},{"path":"/reference/crs_check.html","id":null,"dir":"Reference","previous_headings":"","what":"Check Coordinate Reference System — crs_check","title":"Check Coordinate Reference System — crs_check","text":"returns st_crs object sf/Spat* objects.","code":""},{"path":"/reference/crs_check.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Check Coordinate Reference System — crs_check","text":"","code":"crs_check(x)"},{"path":"/reference/crs_check.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Check Coordinate Reference System — crs_check","text":"x sf/stars/SpatVector/SpatRaster object.","code":""},{"path":"/reference/crs_check.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Check Coordinate Reference System — crs_check","text":"st_crs crs object.","code":""},{"path":"/reference/crs_check.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Check Coordinate Reference System — crs_check","text":"Insang Song geoissong@gmail.com","code":""},{"path":"/reference/crs_check.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Check Coordinate Reference System — crs_check","text":"","code":"# data library(sf) ncpath = system.file(\"shape/nc.shp\", package = \"sf\") nc = read_sf(ncpath) crs_check(nc) #> Coordinate Reference System: #>   User input: NAD27  #>   wkt: #> GEOGCRS[\"NAD27\", #>     DATUM[\"North American Datum 1927\", #>         ELLIPSOID[\"Clarke 1866\",6378206.4,294.978698213898, #>             LENGTHUNIT[\"metre\",1]]], #>     PRIMEM[\"Greenwich\",0, #>         ANGLEUNIT[\"degree\",0.0174532925199433]], #>     CS[ellipsoidal,2], #>         AXIS[\"latitude\",north, #>             ORDER[1], #>             ANGLEUNIT[\"degree\",0.0174532925199433]], #>         AXIS[\"longitude\",east, #>             ORDER[2], #>             ANGLEUNIT[\"degree\",0.0174532925199433]], #>     ID[\"EPSG\",4267]]"},{"path":"/reference/datamod.html","id":null,"dir":"Reference","previous_headings":"","what":"Return the input's GIS data model type — datamod","title":"Return the input's GIS data model type — datamod","text":"function returns one 'vector' 'raster' depending input class.","code":""},{"path":"/reference/datamod.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Return the input's GIS data model type — datamod","text":"","code":"datamod(input)"},{"path":"/reference/datamod.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Return the input's GIS data model type — datamod","text":"input Spat*/sf/stars object.","code":""},{"path":"/reference/datamod.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Return the input's GIS data model type — datamod","text":"character(1). One \"vector\" \"raster\".","code":""},{"path":"/reference/datamod.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Return the input's GIS data model type — datamod","text":"Although stars object little ambiguous whether classify vector raster, considered raster package.","code":""},{"path":"/reference/datamod.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Return the input's GIS data model type — datamod","text":"Insang Song","code":""},{"path":"/reference/datamod.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Return the input's GIS data model type — datamod","text":"","code":"library(sf) library(terra) options(sf_use_s2 = FALSE)  nc_path <- system.file(\"gpkg/nc.gpkg\", package = \"sf\") nc_sf <- sf::st_read(nc_path) #> Reading layer `nc.gpkg' from data source  #>   `/home/runner/work/_temp/Library/sf/gpkg/nc.gpkg' using driver `GPKG' #> Simple feature collection with 100 features and 14 fields #> Geometry type: MULTIPOLYGON #> Dimension:     XY #> Bounding box:  xmin: -84.32385 ymin: 33.88199 xmax: -75.45698 ymax: 36.58965 #> Geodetic CRS:  NAD27 datamod(nc_sf) #> [1] \"vector\"  ra_path <- system.file(\"ex/elev.tif\", package = \"terra\") ra <- terra::rast(ra_path) datamod(ra) #> [1] \"raster\""},{"path":"/reference/dep_check.html","id":null,"dir":"Reference","previous_headings":"","what":"Return the package the input object is based on — dep_check","title":"Return the package the input object is based on — dep_check","text":"Detect whether input object sf Spat* object.","code":""},{"path":"/reference/dep_check.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Return the package the input object is based on — dep_check","text":"","code":"dep_check(input)"},{"path":"/reference/dep_check.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Return the package the input object is based on — dep_check","text":"input Spat* terra sf object.","code":""},{"path":"/reference/dep_check.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Return the package the input object is based on — dep_check","text":"character object; one \"terra\" \"sf\"","code":""},{"path":"/reference/dep_check.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Return the package the input object is based on — dep_check","text":"Insang Song","code":""},{"path":"/reference/dep_check.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Return the package the input object is based on — dep_check","text":"","code":"library(sf) library(terra) options(sf_use_s2 = FALSE)  nc_path <- system.file(\"gpkg/nc.gpkg\", package = \"sf\") nc_sf <- sf::st_read(nc_path) #> Reading layer `nc.gpkg' from data source  #>   `/home/runner/work/_temp/Library/sf/gpkg/nc.gpkg' using driver `GPKG' #> Simple feature collection with 100 features and 14 fields #> Geometry type: MULTIPOLYGON #> Dimension:     XY #> Bounding box:  xmin: -84.32385 ymin: 33.88199 xmax: -75.45698 ymax: 36.58965 #> Geodetic CRS:  NAD27 dep_check(nc_sf) #> [1] \"sf\" nc_vect <- terra::vect(nc_sf) dep_check(nc_vect) #> [1] \"terra\" ## END OF EXAMPLE"},{"path":"/reference/dep_switch.html","id":null,"dir":"Reference","previous_headings":"","what":"Switch spatial data class — dep_switch","title":"Switch spatial data class — dep_switch","text":"Convert class sf/stars-terra","code":""},{"path":"/reference/dep_switch.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Switch spatial data class — dep_switch","text":"","code":"dep_switch(input)"},{"path":"/reference/dep_switch.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Switch spatial data class — dep_switch","text":"input Spat* terra sf object.","code":""},{"path":"/reference/dep_switch.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Switch spatial data class — dep_switch","text":"Data converted package class (sf, terra; terra, sf)","code":""},{"path":"/reference/dep_switch.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Switch spatial data class — dep_switch","text":"Insang Song","code":""},{"path":"/reference/dep_switch.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Switch spatial data class — dep_switch","text":"","code":"library(sf) library(stars) library(terra) options(sf_use_s2 = FALSE)  ## generate a random raster ras_rand <- terra::rast(nrow = 30, ncol = 30) terra::values(ras_rand) <- runif(900) stars_rand <- dep_switch(ras_rand) stars_rand #> stars object with 2 dimensions and 1 attribute #> attribute(s): #>               Min.  1st Qu.    Median      Mean   3rd Qu.      Max. #> lyr.1  0.002977239 0.267624 0.4937182 0.5006182 0.7345819 0.9977391 #> dimension(s): #>   from to offset delta refsys x/y #> x    1 30   -180    12 WGS 84 [x] #> y    1 30     90    -6 WGS 84 [y] # should return stars object  vec_rand <- terra::spatSample(ras_rand, size = 10L, as.points = TRUE) sf_rand <- dep_switch(vec_rand) sf_rand #> Simple feature collection with 10 features and 1 field #> Geometry type: POINT #> Dimension:     XY #> Bounding box:  xmin: -174 ymin: -69 xmax: 162 ymax: 45 #> Geodetic CRS:  WGS 84 #>         lyr.1        geometry #> 1  0.65757560     POINT (6 3) #> 2  0.48918318 POINT (-174 -3) #> 3  0.47051655  POINT (-42 33) #> 4  0.16474325   POINT (162 3) #> 5  0.16927073  POINT (114 39) #> 6  0.55702116 POINT (-66 -69) #> 7  0.02971063  POINT (-42 15) #> 8  0.50855300   POINT (-6 45) #> 9  0.62262545  POINT (-162 3) #> 10 0.59050869   POINT (-66 9) # should return sf object"},{"path":"/reference/ext2poly.html","id":null,"dir":"Reference","previous_headings":"","what":"Generate a rectangular polygon from extent — ext2poly","title":"Generate a rectangular polygon from extent — ext2poly","text":"Generate rectangular polygon extent","code":""},{"path":"/reference/ext2poly.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Generate a rectangular polygon from extent — ext2poly","text":"","code":"ext2poly(extent = NULL, output_class = c(\"sf\", \"terra\"), crs = \"EPSG:4326\")"},{"path":"/reference/ext2poly.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Generate a rectangular polygon from extent — ext2poly","text":"extent input extent. numeric vector xmin/xmax/ymin/ymax, sf::st_bbox terra::ext outputs. output_class character(1). Class output polygon. One \"sf\" \"terra\" crs character(1). Coordinate reference system definition.","code":""},{"path":"/reference/ext2poly.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Generate a rectangular polygon from extent — ext2poly","text":"sf SpatVector object rectangular polygon.","code":""},{"path":"/reference/ext2poly.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Generate a rectangular polygon from extent — ext2poly","text":"Insang Song","code":""},{"path":"/reference/ext2poly.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Generate a rectangular polygon from extent — ext2poly","text":"","code":"library(sf) library(terra) numext1 <- c(-100, -70, 30, 40) names(numext1) <- c(\"xmin\", \"xmax\", \"ymin\", \"ymax\") ext2poly(numext1, \"sf\") #> Simple feature collection with 1 feature and 0 fields #> Geometry type: POLYGON #> Dimension:     XY #> Bounding box:  xmin: -100 ymin: 30 xmax: -70 ymax: 40 #> Geodetic CRS:  WGS 84 #>                                x #> 1 POLYGON ((-100 30, -70 30, ... ext2poly(numext1, \"terra\") #>  class       : SpatVector  #>  geometry    : polygons  #>  dimensions  : 1, 0  (geometries, attributes) #>  extent      : -100, -70, 30, 40  (xmin, xmax, ymin, ymax) #>  coord. ref. : lon/lat WGS 84 (EPSG:4326)"},{"path":"/reference/extract_at.html","id":null,"dir":"Reference","previous_headings":"","what":"Extract raster values with point buffers or polygons — extract_at","title":"Extract raster values with point buffers or polygons — extract_at","text":"Extract raster values point buffers polygons","code":""},{"path":"/reference/extract_at.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Extract raster values with point buffers or polygons — extract_at","text":"","code":"extract_at(   vector = NULL,   raster = NULL,   id = NULL,   func = \"mean\",   mode = c(\"polygon\", \"buffer\"),   ... )"},{"path":"/reference/extract_at.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Extract raster values with point buffers or polygons — extract_at","text":"vector sf/SpatVector object. raster SpatRaster object. id character(1). Unique identifier point. func function taking one numeric vector argument. mode one \"polygon\" (generic polygons extract raster values ) \"buffer\" (point buffer radius) ... various. Passed extract_at_buffer. See ?extract_at_buffer details.","code":""},{"path":"/reference/extract_at.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Extract raster values with point buffers or polygons — extract_at","text":"data.frame object summarized raster values respect mode (polygon buffer) function.","code":""},{"path":[]},{"path":"/reference/extract_at.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Extract raster values with point buffers or polygons — extract_at","text":"Insang Song geoissong@gmail.com","code":""},{"path":"/reference/extract_at.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Extract raster values with point buffers or polygons — extract_at","text":"","code":"## See ?extract_at_poly and ?extract_at_buffer"},{"path":"/reference/extract_at_buffer.html","id":null,"dir":"Reference","previous_headings":"","what":"Extract summarized values from raster with points and a buffer radius — extract_at_buffer","title":"Extract summarized values from raster with points and a buffer radius — extract_at_buffer","text":"simplicity, assumed coordinate systems points raster .","code":""},{"path":"/reference/extract_at_buffer.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Extract summarized values from raster with points and a buffer radius — extract_at_buffer","text":"","code":"extract_at_buffer(   points = NULL,   surf = NULL,   radius = NULL,   id = NULL,   qsegs = 90L,   func = \"mean\",   kernel = NULL,   bandwidth = NULL )  extract_at_buffer_flat(   points = NULL,   surf = NULL,   radius = NULL,   id = NULL,   qsegs = NULL,   func = \"mean\",   kernel = NULL,   bandwidth = NULL )  extract_at_buffer_kernel(   points = NULL,   surf = NULL,   radius = NULL,   id = NULL,   qsegs = NULL,   func = stats::weighted.mean,   kernel = NULL,   bandwidth = NULL )"},{"path":"/reference/extract_at_buffer.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Extract summarized values from raster with points and a buffer radius — extract_at_buffer","text":"points sf/SpatVector object. Coordinates buffers generated. surf SpatRaster object. raster summary calculated radius numeric(1). Buffer radius. assume circular buffers id character(1). Unique identifier point. qsegs integer(1). Number vertices quarter circle. Default 90L. func function taking numeric vector argument. kernel character(1). Name kernel function One \"uniform\", \"triweight\", \"quartic\", \"epanechnikov\" bandwidth numeric(1). Kernel bandwidth.","code":""},{"path":"/reference/extract_at_buffer.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Extract summarized values from raster with points and a buffer radius — extract_at_buffer","text":"data.frame object mean value","code":""},{"path":"/reference/extract_at_buffer.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Extract summarized values from raster with points and a buffer radius — extract_at_buffer","text":"Insang Song geoissong@gmail.com","code":""},{"path":"/reference/extract_at_buffer.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Extract summarized values from raster with points and a buffer radius — extract_at_buffer","text":"","code":"library(terra) rrast <- terra::rast(nrow = 100, ncol = 100) terra::crs(rrast) <- \"EPSG:5070\" terra::values(rrast) <- rgamma(1e4, 4, 2) rpnt <- terra::spatSample(rrast, 100L, as.points = TRUE) rpnt$pid <- sprintf(\"id_%03d\", seq(1, 100)) extract_at_buffer(rpnt, rrast, 4, \"pid\") #>        pid     mean #> 1   id_001 2.088129 #> 2   id_002 1.801404 #> 3   id_003 1.818624 #> 4   id_004 1.713521 #> 5   id_005 1.861658 #> 6   id_006 1.719859 #> 7   id_007 1.974695 #> 8   id_008 2.049741 #> 9   id_009 2.316861 #> 10  id_010 1.916453 #> 11  id_011 2.355014 #> 12  id_012 2.299939 #> 13  id_013 2.039365 #> 14  id_014 2.103469 #> 15  id_015 2.284654 #> 16  id_016 2.215988 #> 17  id_017 1.960786 #> 18  id_018 3.082453 #> 19  id_019 2.374119 #> 20  id_020 2.151488 #> 21  id_021 1.687319 #> 22  id_022 1.919163 #> 23  id_023 2.392955 #> 24  id_024 1.938812 #> 25  id_025 1.650142 #> 26  id_026 1.787531 #> 27  id_027 2.072593 #> 28  id_028 2.150475 #> 29  id_029 1.506016 #> 30  id_030 1.740266 #> 31  id_031 1.698756 #> 32  id_032 2.337476 #> 33  id_033 2.223276 #> 34  id_034 1.862528 #> 35  id_035 2.522879 #> 36  id_036 1.633430 #> 37  id_037 2.207080 #> 38  id_038 1.562899 #> 39  id_039 1.925542 #> 40  id_040 2.149704 #> 41  id_041 2.031895 #> 42  id_042 2.096056 #> 43  id_043 2.927146 #> 44  id_044 1.958425 #> 45  id_045 1.724679 #> 46  id_046 2.121109 #> 47  id_047 1.814018 #> 48  id_048 2.495163 #> 49  id_049 1.461759 #> 50  id_050 2.375083 #> 51  id_051 2.430701 #> 52  id_052 2.516381 #> 53  id_053 1.902838 #> 54  id_054 2.462683 #> 55  id_055 2.037783 #> 56  id_056 2.275699 #> 57  id_057 2.049863 #> 58  id_058 2.527668 #> 59  id_059 2.154519 #> 60  id_060 1.581526 #> 61  id_061 1.722006 #> 62  id_062 1.939144 #> 63  id_063 2.082714 #> 64  id_064 2.135763 #> 65  id_065 2.703117 #> 66  id_066 1.497881 #> 67  id_067 1.821361 #> 68  id_068 1.566550 #> 69  id_069 2.092789 #> 70  id_070 2.161509 #> 71  id_071 2.113995 #> 72  id_072 2.036025 #> 73  id_073 2.370155 #> 74  id_074 2.151327 #> 75  id_075 2.080855 #> 76  id_076 1.938411 #> 77  id_077 2.040131 #> 78  id_078 1.703379 #> 79  id_079 2.363913 #> 80  id_080 1.449415 #> 81  id_081 1.581289 #> 82  id_082 2.187207 #> 83  id_083 1.777520 #> 84  id_084 1.634075 #> 85  id_085 2.001484 #> 86  id_086 1.976651 #> 87  id_087 1.747148 #> 88  id_088 1.643719 #> 89  id_089 1.863137 #> 90  id_090 2.511853 #> 91  id_091 2.203949 #> 92  id_092 2.331332 #> 93  id_093 1.458342 #> 94  id_094 1.926339 #> 95  id_095 1.396570 #> 96  id_096 1.898611 #> 97  id_097 2.262470 #> 98  id_098 2.511716 #> 99  id_099 2.503972 #> 100 id_100 1.715506"},{"path":"/reference/extract_at_poly.html","id":null,"dir":"Reference","previous_headings":"","what":"Extract summarized values from raster with generic polygons — extract_at_poly","title":"Extract summarized values from raster with generic polygons — extract_at_poly","text":"simplicity, assumed coordinate systems points raster . Kernel function yet implemented.","code":""},{"path":"/reference/extract_at_poly.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Extract summarized values from raster with generic polygons — extract_at_poly","text":"","code":"extract_at_poly(polys = NULL, surf = NULL, id = NULL, func = \"mean\")"},{"path":"/reference/extract_at_poly.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Extract summarized values from raster with generic polygons — extract_at_poly","text":"polys sf/SpatVector object. Polygons. surf SpatRaster object. raster summary calculated id character(1). Unique identifier point. func generic function name string function taking two arguments compatible exact_extract. example, \"mean\" \\(x, w) weighted.mean(x, w, na.rm = TRUE)","code":""},{"path":"/reference/extract_at_poly.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Extract summarized values from raster with generic polygons — extract_at_poly","text":"data.frame object function value","code":""},{"path":"/reference/extract_at_poly.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Extract summarized values from raster with generic polygons — extract_at_poly","text":"Insang Song geoissong@gmail.com","code":""},{"path":"/reference/extract_at_poly.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Extract summarized values from raster with generic polygons — extract_at_poly","text":"","code":"ncpath <- system.file(\"gpkg/nc.gpkg\", package = \"sf\") nc <- terra::vect(ncpath) nc <- terra::project(nc, \"EPSG:5070\") rrast <- terra::rast(nc, nrow = 100, ncol = 220) ncr <- terra::rasterize(nc, rrast) terra::values(rrast) <- rgamma(2.2e4, 4, 2) rpnt <- terra::spatSample(rrast, 16L, as.points = TRUE) rpnt$pid <- sprintf(\"ID-%02d\", seq(1, 16)) rpoly <-   terra::buffer(rpnt, 5, capstyle = \"square\", joinstyle = \"bevel\") extract_at_poly(rpoly, rrast, \"pid\") #>      pid      mean #> 1  ID-01 1.9446038 #> 2  ID-02 1.5795212 #> 3  ID-03 3.4680066 #> 4  ID-04 4.3505278 #> 5  ID-05 2.6054471 #> 6  ID-06 0.4906177 #> 7  ID-07 1.2203249 #> 8  ID-08 1.1647725 #> 9  ID-09 1.9721923 #> 10 ID-10 1.6730120 #> 11 ID-11 1.1531056 #> 12 ID-12 4.7801585 #> 13 ID-13 0.6278704 #> 14 ID-14 0.5200240 #> 15 ID-15 2.9709253 #> 16 ID-16 0.9964402"},{"path":"/reference/get_clip_ext.html","id":null,"dir":"Reference","previous_headings":"","what":"Setting the clipping extent — get_clip_ext","title":"Setting the clipping extent — get_clip_ext","text":"Return clipping extent buffer radius. assumes input CRS projected linear unit meters.","code":""},{"path":"/reference/get_clip_ext.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Setting the clipping extent — get_clip_ext","text":"","code":"get_clip_ext(pnts, radius)"},{"path":"/reference/get_clip_ext.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Setting the clipping extent — get_clip_ext","text":"pnts One sf SpatVector object. Target points computation. radius numeric(1). Buffer radius. assumed meters","code":""},{"path":"/reference/get_clip_ext.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Setting the clipping extent — get_clip_ext","text":"terra::ext sfc_POLYGON object computation extent.","code":""},{"path":"/reference/get_clip_ext.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Setting the clipping extent — get_clip_ext","text":"Insang Song","code":""},{"path":"/reference/get_clip_ext.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Setting the clipping extent — get_clip_ext","text":"","code":"library(sf) library(terra) options(sf_use_s2 = FALSE)  nc_path <- system.file(\"gpkg/nc.gpkg\", package = \"sf\") nc_sf <- sf::st_read(nc_path) #> Reading layer `nc.gpkg' from data source  #>   `/home/runner/work/_temp/Library/sf/gpkg/nc.gpkg' using driver `GPKG' #> Simple feature collection with 100 features and 14 fields #> Geometry type: MULTIPOLYGON #> Dimension:     XY #> Bounding box:  xmin: -84.32385 ymin: 33.88199 xmax: -75.45698 ymax: 36.58965 #> Geodetic CRS:  NAD27 nc_sf <- sf::st_transform(nc_sf, \"EPSG:5070\") get_clip_ext(nc_sf, 2.5e4) #> Geometry set for 1 feature  #> Geometry type: POLYGON #> Dimension:     XY #> Bounding box:  xmin: 1026793 ymin: 1320525 xmax: 1860999 ymax: 1716736 #> Projected CRS: NAD83 / Conus Albers #> POLYGON ((1026793 1320525, 1860999 1320525, 186... nc_vect <- terra::vect(nc_sf) get_clip_ext(nc_vect, 2.5e4) #> SpatExtent : 1026793.1576511, 1860998.50656683, 1320525.36229524, 1716735.54884167 (xmin, xmax, ymin, ymax)"},{"path":"/reference/is_bbox_within_reference.html","id":null,"dir":"Reference","previous_headings":"","what":"Check if the data extent is inside the reference bounding box — is_bbox_within_reference","title":"Check if the data extent is inside the reference bounding box — is_bbox_within_reference","text":"One common errors spatial computation rooted entirely partly incomparable spatial extents input datasets. function returns whether data inside target computational extent. assumed know exact computational region. function return TRUE reference region completely contains data's extent FALSE otherwise.","code":""},{"path":"/reference/is_bbox_within_reference.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Check if the data extent is inside the reference bounding box — is_bbox_within_reference","text":"","code":"is_bbox_within_reference(data_query = NULL, reference = NULL)"},{"path":"/reference/is_bbox_within_reference.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Check if the data extent is inside the reference bounding box — is_bbox_within_reference","text":"data_query sf*/stars/SpatVector/SpatRaster object. reference sf*/stars/SpatVector/SpatRaster object","code":""},{"path":"/reference/is_bbox_within_reference.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Check if the data extent is inside the reference bounding box — is_bbox_within_reference","text":"logical(1). TRUE (queried data extent completely within reference bounding box) FALSE","code":""},{"path":"/reference/is_bbox_within_reference.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Check if the data extent is inside the reference bounding box — is_bbox_within_reference","text":"Insang Song geoissong@gmail.com","code":""},{"path":"/reference/is_bbox_within_reference.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Check if the data extent is inside the reference bounding box — is_bbox_within_reference","text":"","code":"library(sf) ncpath <- system.file(\"gpkg/nc.gpkg\", package = \"sf\") nc <- sf::st_read(ncpath) #> Reading layer `nc.gpkg' from data source  #>   `/home/runner/work/_temp/Library/sf/gpkg/nc.gpkg' using driver `GPKG' #> Simple feature collection with 100 features and 14 fields #> Geometry type: MULTIPOLYGON #> Dimension:     XY #> Bounding box:  xmin: -84.32385 ymin: 33.88199 xmax: -75.45698 ymax: 36.58965 #> Geodetic CRS:  NAD27 nc <- sf::st_transform(nc, \"EPSG:4326\")  refextnum <- c(-100, -60, 20, 40) names(refextnum) <- c(\"xmin\", \"xmax\", \"ymin\", \"ymax\") refext <- ext2poly(refextnum) is_bbox_within_reference(nc, refext) #> Coordinate Reference System: #>   User input: EPSG:4326  #>   wkt: #> GEOGCRS[\"WGS 84\", #>     DATUM[\"World Geodetic System 1984\", #>         ELLIPSOID[\"WGS 84\",6378137,298.257223563, #>             LENGTHUNIT[\"metre\",1]]], #>     PRIMEM[\"Greenwich\",0, #>         ANGLEUNIT[\"degree\",0.0174532925199433]], #>     CS[ellipsoidal,2], #>         AXIS[\"geodetic latitude (Lat)\",north, #>             ORDER[1], #>             ANGLEUNIT[\"degree\",0.0174532925199433]], #>         AXIS[\"geodetic longitude (Lon)\",east, #>             ORDER[2], #>             ANGLEUNIT[\"degree\",0.0174532925199433]], #>     USAGE[ #>         SCOPE[\"Horizontal component of 3D system.\"], #>         AREA[\"World.\"], #>         BBOX[-90,-180,90,180]], #>     ID[\"EPSG\",4326]] #> Coordinate Reference System: #>   User input: EPSG:4326  #>   wkt: #> GEOGCRS[\"WGS 84\", #>     DATUM[\"World Geodetic System 1984\", #>         ELLIPSOID[\"WGS 84\",6378137,298.257223563, #>             LENGTHUNIT[\"metre\",1]]], #>     PRIMEM[\"Greenwich\",0, #>         ANGLEUNIT[\"degree\",0.0174532925199433]], #>     CS[ellipsoidal,2], #>         AXIS[\"geodetic latitude (Lat)\",north, #>             ORDER[1], #>             ANGLEUNIT[\"degree\",0.0174532925199433]], #>         AXIS[\"geodetic longitude (Lon)\",east, #>             ORDER[2], #>             ANGLEUNIT[\"degree\",0.0174532925199433]], #>     USAGE[ #>         SCOPE[\"Horizontal component of 3D system.\"], #>         AREA[\"World.\"], #>         BBOX[-90,-180,90,180]], #>     ID[\"EPSG\",4326]] #> although coordinates are longitude/latitude, st_within assumes that they are #> planar #> [1] TRUE"},{"path":"/reference/is_within_ref.html","id":null,"dir":"Reference","previous_headings":"","what":"Check if the boundary of the vector/raster object is inside the reference — is_within_ref","title":"Check if the boundary of the vector/raster object is inside the reference — is_within_ref","text":"Check boundary vector/raster object inside reference","code":""},{"path":"/reference/is_within_ref.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Check if the boundary of the vector/raster object is inside the reference — is_within_ref","text":"","code":"is_within_ref(input_object, reference)"},{"path":"/reference/is_within_ref.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Check if the boundary of the vector/raster object is inside the reference — is_within_ref","text":"input_object sf/stars/SpatVector/SpatRaster object. reference sf/stars/SpatVector/SpatRaster object.","code":""},{"path":"/reference/is_within_ref.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Check if the boundary of the vector/raster object is inside the reference — is_within_ref","text":"logical","code":""},{"path":"/reference/is_within_ref.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Check if the boundary of the vector/raster object is inside the reference — is_within_ref","text":"Insang Song geoissong@gmail.com","code":""},{"path":"/reference/is_within_ref.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Check if the boundary of the vector/raster object is inside the reference — is_within_ref","text":"","code":"library(sf) sf_use_s2(FALSE) ncpath <- system.file(\"shape/nc.shp\", package = \"sf\") nc <- sf::read_sf(ncpath) nc <- sf::st_transform(nc, \"EPSG:4326\") mainland_vec <- c(xmin = -128, xmax = -62, ymin = 22, ymax = 52) mainland_box <- ext2poly(mainland_vec, output_class = \"sf\") within_res <- is_within_ref(nc, mainland_box) #> although coordinates are longitude/latitude, st_covered_by assumes that they #> are planar within_res #> [1] TRUE"},{"path":"/reference/kernelfunction.html","id":null,"dir":"Reference","previous_headings":"","what":"Kernel functions — kernelfunction","title":"Kernel functions — kernelfunction","text":"Kernel functions","code":""},{"path":"/reference/kernelfunction.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Kernel functions — kernelfunction","text":"","code":"kernelfunction(   d,   bw,   kernel = c(\"uniform\", \"quartic\", \"triweight\", \"epanechnikov\") )"},{"path":"/reference/kernelfunction.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Kernel functions — kernelfunction","text":"d Distance bw Bandwidth kernel kernel Kernel type. One \"uniform\", \"quartic\", \"triweight\", \"epanechnikov\"","code":""},{"path":"/reference/kernelfunction.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Kernel functions — kernelfunction","text":"numeric. Kernel weights.","code":""},{"path":"/reference/kernelfunction.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Kernel functions — kernelfunction","text":"SpatialKDE source","code":""},{"path":"/reference/kernelfunction.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Kernel functions — kernelfunction","text":"","code":"v_dist <- c(1, 10, 100, 25, 50, 0.1) bw_dist1 <- 1 bw_dist2 <- 10 kernelfunction(v_dist, bw_dist1, \"uniform\") #> [1] 0.5 0.0 0.0 0.0 0.0 0.5 kernelfunction(v_dist, bw_dist1, \"quartic\") #> [1] 0.0000000 0.0000000 0.0000000 0.0000000 0.0000000 0.9188437 kernelfunction(v_dist, bw_dist1, \"triweight\") #> [1] 0.000 0.000 0.000 0.000 0.000 0.999 kernelfunction(v_dist, bw_dist1, \"epanechnikov\") #> [1] 0.0000 0.0000 0.0000 0.0000 0.0000 0.7425 kernelfunction(v_dist, bw_dist2, \"uniform\") #> [1] 0.5 0.5 0.0 0.0 0.0 0.5 kernelfunction(v_dist, bw_dist2, \"quartic\") #> [1] 0.9188437 0.0000000 0.0000000 0.0000000 0.0000000 0.9373125 kernelfunction(v_dist, bw_dist2, \"triweight\") #> [1] 0.999000 0.000000 0.000000 0.000000 0.000000 0.999999 kernelfunction(v_dist, bw_dist2, \"epanechnikov\") #> [1] 0.742500 0.000000 0.000000 0.000000 0.000000 0.749925"},{"path":"/reference/par_fallback.html","id":null,"dir":"Reference","previous_headings":"","what":"Parallelization error fallback — par_fallback","title":"Parallelization error fallback — par_fallback","text":"Parallelization error fallback","code":""},{"path":"/reference/par_fallback.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Parallelization error fallback — par_fallback","text":"","code":"par_fallback(err = NULL, fun = NULL, debug = FALSE)"},{"path":"/reference/par_fallback.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Parallelization error fallback — par_fallback","text":"err Error status message. fun function. debug logical(1). Print error messages (TRUE) (FALSE)","code":""},{"path":"/reference/par_fallback.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Parallelization error fallback — par_fallback","text":"data.frame one column","code":""},{"path":"/reference/par_fallback.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Parallelization error fallback — par_fallback","text":"function assumes fun argument named \"id\".","code":""},{"path":"/reference/par_fallback.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Parallelization error fallback — par_fallback","text":"Insang Song","code":""},{"path":"/reference/par_fallback.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Parallelization error fallback — par_fallback","text":"","code":"## NO EXAMPLE"},{"path":"/reference/par_grid.html","id":null,"dir":"Reference","previous_headings":"","what":"Process a given function in the entire or partial computational grids — par_grid","title":"Process a given function in the entire or partial computational grids — par_grid","text":"future::multicore, future::multisession, future::cluster doParallel::registerDoParallel parallelize work grid. details terminology future package, refer plan. function assumes users one raster file sizable spatially distributed target locations. thread process ceiling(\\eqn{|N_g|/|N_t|}) grids \\(|N_g|\\) denotes number grids \\(|N_t|\\) denotes number threads.","code":""},{"path":"/reference/par_grid.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Process a given function in the entire or partial computational grids — par_grid","text":"","code":"par_grid(grids, grid_target_id = NULL, debug = FALSE, fun_dist, ...)"},{"path":"/reference/par_grid.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Process a given function in the entire or partial computational grids — par_grid","text":"grids sf/SpatVector object. Computational grids. takes strict assumption grid input output par_make_gridset grid_target_id character(1) numeric(2). Default NULL. NULL, grid_ids used. \"id_from:id_to\" format c(unique(grid_id)[id_from], unique(grid_id)[id_to]) debug logical(1). Prints error messages errors calculation. fun_dist sf, terra chopin functions. ... Arguments passed argument fun_dist. second place get vector raster dataset want extract calculate values. example, raster dataset vector-raster overlay performed.","code":""},{"path":"/reference/par_grid.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Process a given function in the entire or partial computational grids — par_grid","text":"data.frame object computation results. entries results, consult function used fun_dist argument.","code":""},{"path":"/reference/par_grid.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Process a given function in the entire or partial computational grids — par_grid","text":"dynamic dots (...), first second arguments fun_dist arguments sf/SpatVector objects accepted. Virtually sf/terra functions accept two arguments can put fun_dist, please advised spatial operations necessarily give exact result done single-thread. example, distance calculated function may return lower value actual computational region reduced. case especially target features spatially sparsely distributed.","code":""},{"path":"/reference/par_grid.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Process a given function in the entire or partial computational grids — par_grid","text":"Insang Song geoissong@gmail.com","code":""},{"path":"/reference/par_grid.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Process a given function in the entire or partial computational grids — par_grid","text":"","code":"if (FALSE) { library(future) plan(multicore, workers = 4) # See vignette for details. }"},{"path":"/reference/par_hierarchy.html","id":null,"dir":"Reference","previous_headings":"","what":"Process a given function using a hierarchy in input data — par_hierarchy","title":"Process a given function using a hierarchy in input data — par_hierarchy","text":"\"Hierarchy\" refers system, divides entire study region multiple subregions. oftentimes reflected area code system (e.g., FIPS US Census geographies, HUC-4, -6, -8, etc.). future::multicore, future::multisession, future::cluster doParallel::registerDoParallel parallelize work grid. details terminology future package, refer plan. function assumes users one raster file sizable spatially distributed target locations. thread process ceiling(\\eqn{|N_{g}|/|N_{t}|}) grids \\(|N_{g}|\\) denotes number grids \\(|N_{t}|\\) denotes number threads. Please advised accessing file simultaneously multiple processes may result errors.","code":""},{"path":"/reference/par_hierarchy.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Process a given function using a hierarchy in input data — par_hierarchy","text":"","code":"par_hierarchy(regions, split_level = NULL, debug = FALSE, fun_dist, ...)"},{"path":"/reference/par_hierarchy.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Process a given function using a hierarchy in input data — par_hierarchy","text":"regions sf/SpatVector object. Computational regions. polygons accepted. split_level character(nrow(regions)) character(1). regions split common level value. level higher original data level. field name higher level information also accepted. debug logical(1). Prints error messages errors calculation. fun_dist sf, terra, chopin functions. ... Arguments passed argument fun_dist. second place get vector raster dataset want extract calculate values. example, raster dataset vector-raster overlay performed.","code":""},{"path":"/reference/par_hierarchy.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Process a given function using a hierarchy in input data — par_hierarchy","text":"data.frame object computation results. entries results, consult function used fun_dist argument.","code":""},{"path":"/reference/par_hierarchy.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Process a given function using a hierarchy in input data — par_hierarchy","text":"dynamic dots (...), first second arguments fun_dist arguments sf/SpatVector objects accepted. Virtually sf/terra functions accept two arguments can put fun_dist, please advised spatial operations necessarily give exact result done single-thread. example, distance calculated function may return lower value actual computational region reduced. case especially target features spatially sparsely distributed.","code":""},{"path":"/reference/par_hierarchy.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Process a given function using a hierarchy in input data — par_hierarchy","text":"Insang Song geoissong@gmail.com","code":""},{"path":"/reference/par_hierarchy.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Process a given function using a hierarchy in input data — par_hierarchy","text":"","code":"if (FALSE) { library(future) plan(multicore, workers = 4L) # See vignette for details. }"},{"path":"/reference/par_make_grid.html","id":null,"dir":"Reference","previous_headings":"","what":"Generate grid polygons — par_make_grid","title":"Generate grid polygons — par_make_grid","text":"Returns sf object includes x- y- index using two inputs ncutsx ncutsy, x- y-directional splits, respectively.","code":""},{"path":"/reference/par_make_grid.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Generate grid polygons — par_make_grid","text":"","code":"par_make_grid(points_in, ncutsx, ncutsy)"},{"path":"/reference/par_make_grid.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Generate grid polygons — par_make_grid","text":"points_in sf SpatVector object. Target points computation. ncutsx integer(1). number splits along x-axis. ncutsy integer(1). number splits along y-axis.","code":""},{"path":"/reference/par_make_grid.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Generate grid polygons — par_make_grid","text":"sf SpatVector object computation grids unique grid id (CGRIDID).","code":""},{"path":"/reference/par_make_grid.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Generate grid polygons — par_make_grid","text":"Grids generated based extent points_in first, exhaustive grids filtered intersection points_in. Thus, number generated grids may smaller ncutsx * ncutsy.","code":""},{"path":"/reference/par_make_grid.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Generate grid polygons — par_make_grid","text":"Insang Song","code":""},{"path":"/reference/par_make_grid.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Generate grid polygons — par_make_grid","text":"","code":"library(sf) library(terra) options(sf_use_s2 = FALSE)  nc_path <- system.file(\"gpkg/nc.gpkg\", package = \"sf\") nc <- terra::vect(nc_path) nc_rp <- terra::spatSample(nc, 1000) nc_gr <- par_make_grid(nc_rp, 10L, 6L)  plot(nc_rp) plot(nc_gr, add = TRUE)"},{"path":"/reference/par_make_gridset.html","id":null,"dir":"Reference","previous_headings":"","what":"Get a set of computational regions — par_make_gridset","title":"Get a set of computational regions — par_make_gridset","text":"Using input points, bounding box split predefined numbers columns rows. grid buffered radius.","code":""},{"path":"/reference/par_make_gridset.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Get a set of computational regions — par_make_gridset","text":"","code":"par_make_gridset(   input,   mode = c(\"grid\", \"grid_advanced\", \"density\"),   nx = 10L,   ny = 10L,   grid_min_features = 30L,   padding = NULL,   unit = NULL,   ... )"},{"path":"/reference/par_make_gridset.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Get a set of computational regions — par_make_gridset","text":"input sf Spat* object. mode character(1). Mode region construction. One \"grid\" (simple grid regardless number features grid), \"density\" (clustering-based varying grids), \"grid_advanced\" (merging adjacent grids smaller number features grid_min_features). nx integer(1). number grids along x-axis. ny integer(1). number grids along y-axis. grid_min_features integer(1). threshold merging adjacent grids padding numeric(1). extrusion factor make buffer clip actual datasets. Depending length unit CRS input. unit character(1). length unit padding (optional). units::set_units used padding sf object used. See units package vignette (web) list acceptable unit forms. ... arguments passed internal function","code":""},{"path":"/reference/par_make_gridset.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Get a set of computational regions — par_make_gridset","text":"list two, original: exhaustive non-overlapping grid polygons class input padded: square buffer polygon original. Used computation.","code":""},{"path":"/reference/par_make_gridset.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Get a set of computational regions — par_make_gridset","text":"Insang Song","code":""},{"path":"/reference/par_make_gridset.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Get a set of computational regions — par_make_gridset","text":"","code":"# data library(sf) ncpath <- system.file(\"shape/nc.shp\", package = \"sf\") nc <- read_sf(ncpath) nc <- st_transform(nc, \"EPSG:5070\") # run: nx and ny should strictly be integers # In the example below, nx is 12L, not 12. nc_comp_region <-   par_make_gridset(     nc,     mode = \"grid\",     nx = 12L, ny = 8L,     padding = 10000) par(mfcol = c(1, 2)) plot(nc_comp_region$original)  plot(nc_comp_region$padded)"},{"path":"/reference/par_merge_grid.html","id":null,"dir":"Reference","previous_headings":"","what":"Merge adjacent grid polygons with given rules — par_merge_grid","title":"Merge adjacent grid polygons with given rules — par_merge_grid","text":"Merge boundary-sharing (\"Rook\" contiguity) grids fewer target features threshold. function strongly assumes input returned par_make_grid, \"CGRIDID\" unique id field.","code":""},{"path":"/reference/par_merge_grid.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Merge adjacent grid polygons with given rules — par_merge_grid","text":"","code":"par_merge_grid(points_in, grid_in, grid_min_features)"},{"path":"/reference/par_merge_grid.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Merge adjacent grid polygons with given rules — par_merge_grid","text":"points_in sf SpatVector object. Target points computation. grid_in sf SpatVector object. grid generated par_make_grid. grid_min_features integer(1). Threshold merge adjacent grids.","code":""},{"path":"/reference/par_merge_grid.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Merge adjacent grid polygons with given rules — par_merge_grid","text":"sf SpatVector object computation grids.","code":""},{"path":"/reference/par_merge_grid.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Merge adjacent grid polygons with given rules — par_merge_grid","text":"Insang Song","code":""},{"path":"/reference/par_merge_grid.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Merge adjacent grid polygons with given rules — par_merge_grid","text":"","code":"if (FALSE) { library(sf) library(igraph) ligrary(dplyr) dg <- sf::st_as_sfc(st_bbox(c(xmin = 0, ymin = 0, xmax = 8e5, ymax = 6e5))) sf::st_crs(dg) <- 5070 dgs <- sf::st_as_sf(st_make_grid(dg, n = c(20, 15))) dgs$CGRIDID <- seq(1, nrow(dgs))  dg_sample <- sf::st_sample(dg, kappa = 5e-9, mu = 15, scale = 15000, type = \"Thomas\") sf::st_crs(dg_sample) <- sf::st_crs(dg) dg_merged <- par_merge_grid(sf::st_as_sf(dg_sample), dgs, 100) plot(dg_merged$geometry) #### NOT RUN #### }"},{"path":"/reference/par_multirasters.html","id":null,"dir":"Reference","previous_headings":"","what":"Process a given function over multiple large rasters — par_multirasters","title":"Process a given function over multiple large rasters — par_multirasters","text":"Large raster files usually exceed memory capacity size. Cropping large raster small subset even consumes lot memory adds processing time. function leverages terra SpatRaster proxy distribute computation jobs multiple cores. assumed users multiple large raster files disk, file path assigned thread. thread directly read raster values disk using C++ pointers operate terra functions. use, strongly recommended use vector data small confined spatial extent computation avoid --memory error. , users may need make subsets input vector objects advance.","code":""},{"path":"/reference/par_multirasters.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Process a given function over multiple large rasters — par_multirasters","text":"","code":"par_multirasters(filenames, debug = FALSE, fun_dist, ...)"},{"path":"/reference/par_multirasters.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Process a given function over multiple large rasters — par_multirasters","text":"filenames character(n). vector list full file paths raster files. n total number raster files. debug logical(1). Prints error messages errors calculation. fun_dist sf, terra, chopin functions. ... Arguments passed argument fun_dist. second place get vector raster dataset want extract calculate values. example, raster dataset vector-raster overlay performed.","code":""},{"path":"/reference/par_multirasters.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Process a given function over multiple large rasters — par_multirasters","text":"data.frame object computation results. entries results, consult function used fun_dist argument.","code":""},{"path":"/reference/par_multirasters.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Process a given function over multiple large rasters — par_multirasters","text":"Insang Song geoissong@gmail.com","code":""},{"path":"/reference/par_multirasters.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Process a given function over multiple large rasters — par_multirasters","text":"","code":"if (FALSE) { library(future) plan(multisession, workers = 4L) # See vignette for details. }"},{"path":"/reference/prediction_grid.html","id":null,"dir":"Reference","previous_headings":"","what":"Regular grid points in the mainland United States at 1km spatial resolution — prediction_grid","title":"Regular grid points in the mainland United States at 1km spatial resolution — prediction_grid","text":"Regular grid points mainland United States 1km spatial resolution","code":""},{"path":"/reference/prediction_grid.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Regular grid points in the mainland United States at 1km spatial resolution — prediction_grid","text":"","code":"prediction_grid"},{"path":"/reference/prediction_grid.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Regular grid points in the mainland United States at 1km spatial resolution — prediction_grid","text":"data frame 8,092,995 rows three variables: site_id Unique point identifier. Arbitrarily generated. lon Longitude lat Latitude","code":""},{"path":"/reference/prediction_grid.html","id":"source","dir":"Reference","previous_headings":"","what":"Source","title":"Regular grid points in the mainland United States at 1km spatial resolution — prediction_grid","text":"Mainland United States polygon obtained US Census Bureau.","code":""},{"path":"/reference/prediction_grid.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Regular grid points in the mainland United States at 1km spatial resolution — prediction_grid","text":"Coordinates EPSG:5070 (Conus Albers Equal Area)","code":""},{"path":"/reference/prediction_grid.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Regular grid points in the mainland United States at 1km spatial resolution — prediction_grid","text":"","code":"data(\"prediction_grid\", package = \"chopin\")"},{"path":"/reference/rast_short.html","id":null,"dir":"Reference","previous_headings":"","what":"Quick call for SpatRaster with a window — rast_short","title":"Quick call for SpatRaster with a window — rast_short","text":"Quick call SpatRaster window","code":""},{"path":"/reference/rast_short.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Quick call for SpatRaster with a window — rast_short","text":"","code":"rast_short(rasterpath = NULL, win = NULL)"},{"path":"/reference/rast_short.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Quick call for SpatRaster with a window — rast_short","text":"rasterpath character(1). Path raster file. win Named integer vector (4) terra::ext() results.","code":""},{"path":"/reference/rast_short.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Quick call for SpatRaster with a window — rast_short","text":"SpatRaster object.","code":""},{"path":"/reference/rast_short.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Quick call for SpatRaster with a window — rast_short","text":"Insang Song","code":""},{"path":"/reference/rast_short.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Quick call for SpatRaster with a window — rast_short","text":"","code":"library(terra) bcsd_path <- system.file(package = \"stars\", \"nc/bcsd_obs_1999.nc\") ext_small <- terra::ext(   c(xmin = -80, xmax = -76, ymin = 35, ymax = 36) ) rast_short(bcsd_path, ext_small) #> class       : SpatRaster  #> dimensions  : 8, 32, 24  (nrow, ncol, nlyr) #> resolution  : 0.125, 0.125  (x, y) #> window      : -80, -76, 35, 36  (xmin, xmax, ymin, ymax) #> coord. ref. : lon/lat WGS 84  #> sources     : bcsd_obs_1999.nc:pr  (12 layers)  #>               bcsd_obs_1999.nc:tas  (12 layers)  #> varnames    : pr (monthly_sum_pr)  #>               tas (monthly_avg_tas)  #> names       : pr_1, pr_2, pr_3, pr_4, pr_5, pr_6, ...  #> unit        : mm/m, mm/m, mm/m, mm/m, mm/m, mm/m, ...  #> time (days) : 1999-01-31 to 1999-12-31"},{"path":"/reference/reproject_b2r.html","id":null,"dir":"Reference","previous_headings":"","what":"Align vector CRS to raster's — reproject_b2r","title":"Align vector CRS to raster's — reproject_b2r","text":"Align vector CRS raster's","code":""},{"path":"/reference/reproject_b2r.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Align vector CRS to raster's — reproject_b2r","text":"","code":"reproject_b2r(vector, raster)"},{"path":"/reference/reproject_b2r.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Align vector CRS to raster's — reproject_b2r","text":"vector sf/stars/SpatVector/SpatRaster object raster SpatRaster object","code":""},{"path":"/reference/reproject_b2r.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Align vector CRS to raster's — reproject_b2r","text":"Reprojected object class vector","code":""},{"path":"/reference/reproject_b2r.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Align vector CRS to raster's — reproject_b2r","text":"Insang Song","code":""},{"path":"/reference/reproject_b2r.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Align vector CRS to raster's — reproject_b2r","text":"","code":"# NOT TO RUN"},{"path":"/reference/reproject_std.html","id":null,"dir":"Reference","previous_headings":"","what":"Check coordinate system then reproject — reproject_std","title":"Check coordinate system then reproject — reproject_std","text":"input checked whether coordinate system present. , reprojected CRS specified crs_standard.","code":""},{"path":"/reference/reproject_std.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Check coordinate system then reproject — reproject_std","text":"","code":"reproject_std(input, crs_standard = \"EPSG:4326\")"},{"path":"/reference/reproject_std.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Check coordinate system then reproject — reproject_std","text":"input Input object one sf terra::Spat* object crs_standard character(1). standard definition coordinate reference system. Default \"EPSG:4326\" Consult epsg.io details CRS.","code":""},{"path":"/reference/reproject_std.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Check coordinate system then reproject — reproject_std","text":"(reprojected) sf SpatVector object.","code":""},{"path":"/reference/reproject_std.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Check coordinate system then reproject — reproject_std","text":"function works well EPSG codes.","code":""},{"path":"/reference/reproject_std.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Check coordinate system then reproject — reproject_std","text":"Insang Song","code":""},{"path":"/reference/reproject_std.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Check coordinate system then reproject — reproject_std","text":"","code":"library(sf) library(terra) options(sf_use_s2 = FALSE)  base_crs <- \"EPSG:5070\" nc_path <- system.file(\"gpkg/nc.gpkg\", package = \"sf\") nc_sf <- sf::st_read(nc_path) #> Reading layer `nc.gpkg' from data source  #>   `/home/runner/work/_temp/Library/sf/gpkg/nc.gpkg' using driver `GPKG' #> Simple feature collection with 100 features and 14 fields #> Geometry type: MULTIPOLYGON #> Dimension:     XY #> Bounding box:  xmin: -84.32385 ymin: 33.88199 xmax: -75.45698 ymax: 36.58965 #> Geodetic CRS:  NAD27 reproject_std(nc_sf, base_crs) #> Simple feature collection with 100 features and 14 fields #> Geometry type: MULTIPOLYGON #> Dimension:     XY #> Bounding box:  xmin: 1054293 ymin: 1348025 xmax: 1833499 ymax: 1689236 #> Projected CRS: NAD83 / Conus Albers #> First 10 features: #>     AREA PERIMETER CNTY_ CNTY_ID        NAME  FIPS FIPSNO CRESS_ID BIR74 SID74 #> 1  0.114     1.442  1825    1825        Ashe 37009  37009        5  1091     1 #> 2  0.061     1.231  1827    1827   Alleghany 37005  37005        3   487     0 #> 3  0.143     1.630  1828    1828       Surry 37171  37171       86  3188     5 #> 4  0.070     2.968  1831    1831   Currituck 37053  37053       27   508     1 #> 5  0.153     2.206  1832    1832 Northampton 37131  37131       66  1421     9 #> 6  0.097     1.670  1833    1833    Hertford 37091  37091       46  1452     7 #> 7  0.062     1.547  1834    1834      Camden 37029  37029       15   286     0 #> 8  0.091     1.284  1835    1835       Gates 37073  37073       37   420     0 #> 9  0.118     1.421  1836    1836      Warren 37185  37185       93   968     4 #> 10 0.124     1.428  1837    1837      Stokes 37169  37169       85  1612     1 #>    NWBIR74 BIR79 SID79 NWBIR79                           geom #> 1       10  1364     0      19 MULTIPOLYGON (((1288822 156... #> 2       10   542     3      12 MULTIPOLYGON (((1307047 158... #> 3      208  3616     6     260 MULTIPOLYGON (((1378070 157... #> 4      123   830     2     145 MULTIPOLYGON (((1765395 166... #> 5     1066  1606     3    1197 MULTIPOLYGON (((1661822 163... #> 6      954  1838     5    1237 MULTIPOLYGON (((1703230 163... #> 7      115   350     2     139 MULTIPOLYGON (((1765395 166... #> 8      254   594     2     371 MULTIPOLYGON (((1716728 165... #> 9      748  1190     2     844 MULTIPOLYGON (((1566041 161... #> 10     160  2038     5     176 MULTIPOLYGON (((1415754 158...  nc_vect <- terra::vect(nc_sf) reproject_std(nc_vect, base_crs) #>  class       : SpatVector  #>  geometry    : polygons  #>  dimensions  : 100, 14  (geometries, attributes) #>  extent      : 1054293, 1833499, 1348025, 1689236  (xmin, xmax, ymin, ymax) #>  coord. ref. : NAD83 / Conus Albers (EPSG:5070)  #>  names       :  AREA PERIMETER CNTY_ CNTY_ID      NAME  FIPS    FIPSNO CRESS_ID #>  type        : <num>     <num> <num>   <num>     <chr> <chr>     <num>    <int> #>  values      : 0.114     1.442  1825    1825      Ashe 37009 3.701e+04        5 #>                0.061     1.231  1827    1827 Alleghany 37005   3.7e+04        3 #>                0.143      1.63  1828    1828     Surry 37171 3.717e+04       86 #>  BIR74 SID74 (and 4 more) #>  <num> <num>              #>   1091     1              #>    487     0              #>   3188     5"},{"path":"/reference/summarize_aw.html","id":null,"dir":"Reference","previous_headings":"","what":"Area weighted summary using two polygon sf or SpatVector objects — summarize_aw","title":"Area weighted summary using two polygon sf or SpatVector objects — summarize_aw","text":"poly_in poly_weight different classes, poly_weight converted class poly_in.","code":""},{"path":"/reference/summarize_aw.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Area weighted summary using two polygon sf or SpatVector objects — summarize_aw","text":"","code":"summarize_aw(poly_in = NULL, poly_weight = NULL, id_poly_in = \"ID\")"},{"path":"/reference/summarize_aw.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Area weighted summary using two polygon sf or SpatVector objects — summarize_aw","text":"poly_in sf/SpatVector object weighted means calculated. poly_weight sf/SpatVector object weighted means calculated. id_poly_in character(1). unique identifier polygon poly_in","code":""},{"path":"/reference/summarize_aw.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Area weighted summary using two polygon sf or SpatVector objects — summarize_aw","text":"data.frame numeric fields area-weighted means.","code":""},{"path":"/reference/summarize_aw.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Area weighted summary using two polygon sf or SpatVector objects — summarize_aw","text":"Insang Song geoissong@gmail.com","code":""},{"path":"/reference/summarize_aw.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Area weighted summary using two polygon sf or SpatVector objects — summarize_aw","text":"","code":"# package library(sf) sf_use_s2(FALSE) # run nc <- sf::st_read(system.file(\"shape/nc.shp\", package=\"sf\")) #> Reading layer `nc' from data source  #>   `/home/runner/work/_temp/Library/sf/shape/nc.shp' using driver `ESRI Shapefile' #> Simple feature collection with 100 features and 14 fields #> Geometry type: MULTIPOLYGON #> Dimension:     XY #> Bounding box:  xmin: -84.32385 ymin: 33.88199 xmax: -75.45698 ymax: 36.58965 #> Geodetic CRS:  NAD27 nc <- sf::st_transform(nc, 5070) pp <- sf::st_sample(nc, size = 300) pp <- sf::st_as_sf(pp) pp[[\"id\"]] <- seq(1, nrow(pp)) sf::st_crs(pp) <- \"EPSG:5070\" ppb <- sf::st_buffer(pp, nQuadSegs=180, dist = units::set_units(20, 'km'))  system.time({ppb_nc_aw <- summarize_aw(ppb, nc, 'id')}) #>    user  system elapsed  #>   0.347   0.008   0.355  summary(ppb_nc_aw) #>       AREA           PERIMETER         CNTY_         CNTY_ID     #>  Min.   :0.06739   Min.   :1.171   Min.   :1826   Min.   :1826   #>  1st Qu.:0.11700   1st Qu.:1.510   1st Qu.:1926   1st Qu.:1926   #>  Median :0.13450   Median :1.709   Median :2006   Median :2006   #>  Mean   :0.14376   Mean   :1.791   Mean   :2004   Mean   :2004   #>  3rd Qu.:0.16662   3rd Qu.:1.980   3rd Qu.:2081   3rd Qu.:2081   #>  Max.   :0.24000   Max.   :3.640   Max.   :2241   Max.   :2241   #>      FIPSNO         CRESS_ID          BIR74             SID74        #>  Min.   :37008   Min.   : 4.336   Min.   :  323.3   Min.   : 0.000   #>  1st Qu.:37079   1st Qu.:40.148   1st Qu.: 1632.5   1st Qu.: 3.492   #>  Median :37106   Median :53.691   Median : 2858.6   Median : 5.948   #>  Mean   :37105   Mean   :52.784   Mean   : 3467.2   Mean   : 7.312   #>  3rd Qu.:37132   3rd Qu.:66.333   3rd Qu.: 4215.8   3rd Qu.:10.076   #>  Max.   :37188   Max.   :94.746   Max.   :17769.9   Max.   :32.991   #>     NWBIR74             BIR79             SID79           NWBIR79        #>  Min.   :   4.019   Min.   :  402.7   Min.   : 0.000   Min.   :  11.38   #>  1st Qu.: 330.949   1st Qu.: 1977.4   1st Qu.: 4.136   1st Qu.: 418.76   #>  Median : 928.608   Median : 3531.1   Median : 6.815   Median :1166.85   #>  Mean   :1160.604   Mean   : 4433.8   Mean   : 8.782   Mean   :1479.70   #>  3rd Qu.:1626.673   3rd Qu.: 5364.1   3rd Qu.:12.133   3rd Qu.:1992.03   #>  Max.   :6106.569   Max.   :22992.2   Max.   :49.638   Max.   :9181.41   #>           geometry   #>  POLYGON      :300   #>  epsg:5070    :  0   #>  +proj=aea ...:  0   #>                      #>                      #>                      #### Example of summarize_aw ends ####"},{"path":"/reference/summarize_sedc.html","id":null,"dir":"Reference","previous_headings":"","what":"Calculate Sum of Exponentially Decaying Contributions (SEDC) covariates — summarize_sedc","title":"Calculate Sum of Exponentially Decaying Contributions (SEDC) covariates — summarize_sedc","text":"Calculate Sum Exponentially Decaying Contributions (SEDC) covariates","code":""},{"path":"/reference/summarize_sedc.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Calculate Sum of Exponentially Decaying Contributions (SEDC) covariates — summarize_sedc","text":"","code":"summarize_sedc(   point_from = NULL,   point_to = NULL,   id = NULL,   sedc_bandwidth = NULL,   threshold = NULL,   target_fields = NULL )"},{"path":"/reference/summarize_sedc.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Calculate Sum of Exponentially Decaying Contributions (SEDC) covariates — summarize_sedc","text":"point_from SpatVector object. Locations sum SEDCs calculated. point_to SpatVector object. Locations SEDC calculated. id character(1). Name unique id field point_to. sedc_bandwidth numeric(1). Distance source concentration reduced exp(-3) (approximately -95 %) threshold numeric(1). computational efficiency, nearest points threshold selected. Default 2 * sedc_bandwidth. target_fields character(varying). Field names characters.","code":""},{"path":"/reference/summarize_sedc.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Calculate Sum of Exponentially Decaying Contributions (SEDC) covariates — summarize_sedc","text":"data.frame (tibble) object input field names suffix \"_sedc\" sums EDC stored. Additional attributes attached EDC information. attr(result, \"sedc_bandwidth\"): bandwidth concentration reduces approximately five percent attr(result, \"sedc_threshold\"): threshold distance emission source points excluded beyond ","code":""},{"path":"/reference/summarize_sedc.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Calculate Sum of Exponentially Decaying Contributions (SEDC) covariates — summarize_sedc","text":"Distance calculation done terra functions internally. Thus, function internally converts sf objects point_* arguments terra. threshold carefully chosen users.","code":""},{"path":"/reference/summarize_sedc.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Calculate Sum of Exponentially Decaying Contributions (SEDC) covariates — summarize_sedc","text":"Messier KP, Akita Y, \\& Serre ML. (2012). Integrating Address Geocoding, Land Use Regression, Spatiotemporal Geostatistical Estimation Groundwater Tetrachloroethylene. Environmental Science \\& Technology 46(5), 2772-2780. Wiesner C. (n.d.). Euclidean Sum Exponentially Decaying Contributions Tutorial","code":""},{"path":"/reference/summarize_sedc.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Calculate Sum of Exponentially Decaying Contributions (SEDC) covariates — summarize_sedc","text":"Insang Song","code":""},{"path":"/reference/summarize_sedc.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Calculate Sum of Exponentially Decaying Contributions (SEDC) covariates — summarize_sedc","text":"","code":"library(terra) library(sf) set.seed(101) ncpath <- system.file(\"gpkg/nc.gpkg\", package = \"sf\") nc <- terra::vect(ncpath) nc <- terra::project(nc, \"EPSG:5070\") pnt_from <- terra::centroids(nc, inside = TRUE) pnt_from <- pnt_from[, \"NAME\"] pnt_to <- terra::spatSample(nc, 100L) pnt_to$pid <- seq(1, 100) pnt_to <- pnt_to[, \"pid\"] pnt_to$val1 <- rgamma(100L, 1, 0.05) pnt_to$val2 <- rgamma(100L, 2, 1)  vals <- c(\"val1\", \"val2\") summarize_sedc(pnt_from, pnt_to, \"NAME\", 1e5, 2e5, vals) #> Joining with `by = join_by(from_id)` #> Joining with `by = join_by(to_id)` #> Joining with `by = join_by(from_id, to_id)` #> # A tibble: 100 × 3 #>    NAME      val1_sedc val2_sedc #>    <chr>         <dbl>     <dbl> #>  1 Alamance       66.3      6.71 #>  2 Alexander      98.0     11.7  #>  3 Alleghany     135.       8.57 #>  4 Anson          50.0      5.23 #>  5 Ashe          143.       8.42 #>  6 Avery          76.1      8.76 #>  7 Beaufort       58.8      6.29 #>  8 Bertie         70.1      7.85 #>  9 Bladen         79.5      6.82 #> 10 Brunswick      54.3      5.34 #> # ℹ 90 more rows"},{"path":"/reference/vect_valid_repair.html","id":null,"dir":"Reference","previous_headings":"","what":"Validate and repair input vector data — vect_valid_repair","title":"Validate and repair input vector data — vect_valid_repair","text":"tries repairing input vector data. Vector validity violation usually appears polygon data self-crossing hole orders. function pass input_vector object sf::st_make_valid (input_vector sf) terra::makeValid (input_vector SpatVector). May take time depending geometry complexity.","code":""},{"path":"/reference/vect_valid_repair.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Validate and repair input vector data — vect_valid_repair","text":"","code":"vect_valid_repair(input_vector)"},{"path":"/reference/vect_valid_repair.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Validate and repair input vector data — vect_valid_repair","text":"input_vector One sf vect class. Target points computation.","code":""},{"path":"/reference/vect_valid_repair.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Validate and repair input vector data — vect_valid_repair","text":"repaired sf SpatVector object depending class input_vector.","code":""},{"path":"/reference/vect_valid_repair.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Validate and repair input vector data — vect_valid_repair","text":"Insang Song","code":""},{"path":"/reference/vect_valid_repair.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Validate and repair input vector data — vect_valid_repair","text":"","code":"if (FALSE) { library(terra) library(sf) ncpath <- system.file(\"gpkg/nc.gpkg\", package = \"sf\") nc <- terra::vect(ncpath)  nc_valid <- vect_valid_repair(nc) }"}]
